#include "undergrad.hpp"
using namespace std;
using namespace cv;

/*
Occupancy Grid Scheme:
0 - Occupied by robot
1 - Unoccupied
2 - Occupied by cargo
3 - Occupied by arena
*/

int state = -1; // State of robot in FSM
static bool autonomous = 0; // IMPORTANT Flag for whether robot should follow autonomous path or just go wherever the mouse click tells it to
static bool basic = 1; // Flag for whether we go with basic hard code for autonomous challenge
int stopped; // Tells whether robot should stop moving and stop the thread

/* global MMC variables */
static float PgainMMC = 10;   // P gain in MMC
static float IgainMMC = 0;   // I gain in MMC
static float DgainMMC = 0;   // D gain in MMC
static int botCoorX = 474; // Bottom x coordinate of arena
static int botCoorY = 449; // Bottom y coordinate of arena
static int leftCoorX = 194; // Left x coordinate of arena
static int leftCoorY = 367; // Left y coordinate of arena
static int finalCoorX = 162; // Left x coordinate of arena
static int finalCoorY = 275; // Left y coordinate of arena
static int offsetBotY = 75; // Offset in y direction from bottom of arena to move robot to
static float offset_cargo = 100; // Offset from cargo to ensure proper mounting
static float thresh_mount = 55; // Number of pixels that robot can be off from mounting position
static float thresh_bot = 15; // Number of pixels that robot can be off from reaching bottom of arena
static float thresh_left = 15; // Number of pixels that robot can be off from reaching left of arena
static float thresh_backup = 50; // Number of pixels that robot can be close to cargo from reaching backing up from cargo
float heading = 0; // Current angular displacement of robot from cargo
int reversal_override = 0; // If 1, robot goes backward no matter what

float dist_cargo_iteration; // Distance between previous and current location of cargo
float thresh_cargo = 15; // How much distance the cargo can realistically move between frames

static int MMCThread = 0;   // MMC flag :: initially disabled
static int gradient_on = 1; // 1 means gradient field is on
static int uniform_on = 0; // 0 means uniform field is on
static float thresh = 2.0; // Distance in pixels that center of mass of robot can be from goal location
static bool mountable = 0; // Flag for when the robot is able to mount to the cargo
static float goal_orientation; // Goal orientation that the cargo should take on
static int num_points = 6; // Number of points required for calibration
static int thickness; // Thickness of walls in pixels
static int cargo_type = 0; // 0 for circle, 1 for rectangle, 2 for triangle

/* tilt angle variables */
static int fVibrate = 1; // Flag for whether the robot should conduct stick slip motion
float tiltAngle = 20;           // tilting angle of degrees
static float freq = 15;                // frequency of vibration
float ampXY = 1;                // field amplitude in voltage
float ampZ  = ampXY * tand(tiltAngle);

/* Output voltage variables for coil (gradient vs. uniform field) */
static float outputVolt[6] = {0,0,0,0,0,0};                         // output voltage to amplifiers
static float uniformFieldVolt[6] = {0,0,0,0,0,0};
static float gradientFieldVolt[4] = {0,0,0,0};                      // gradient field signal voltage
static float pullGain = 5.0;                        // Gain for calculating field gradient for pulling
static float B_strength_MA = 7; // Strength of magnetic field in mT
static float Coilpair_ratio_MA = 1; // ratio between the pair of coils
static float  saturationGradientFieldVolt = 1; // saturation field strength for gradient generation

/* Path Planning variables */
int** occ_grid = new int*[ROW];     // ROW defined in astar.hpp
stack<Pair> Path; // Stack of positions to be generated by A*
stack<Pair> Path_vision; // Stack of positions for use by vision code
static float* robot_pos[1]; // Current location of microrobot
float cargo_pos_prevX, cargo_pos_prevY; // Keep track of old location of cargo to avoid noisy detections
float* cargo_pos[1]; // Goal location of cargo
static float* goal_pos[1]; // Goal location of next position for microrobot to align with cargo at first
static float* click_pos[1]; // Location to actually have the robot move towards
static float look_ahead = 180; // Distance away from goal position that we should click on the screen
static float tol = 35; // Distance behind cargo that robot's centre of mass should go to
static float max_angdiff = 90; // Maximum angular difference that robot can rotate in one shot to avoid flipping
static float next_ang; // Store next angle for robot to rotate towards incrementally towards
static float desired_ang; // Store desired orientation of cargo
static float final_ang; // Store final angle the robot should rotate towards

/* Visualization variables */
int draw_x = 525, draw_y = 132, click_x = 1, click_y = 1;   // Visualization variables
float REF_coorX = 0, REF_coorY = 0; // CUrrent position that robot is trying to follow

/* file-wide functions */
static int saturate_gradient_field_signal () {
    if (gradientFieldVolt[0] > saturationGradientFieldVolt) { // to avoid singularities in X  default constant 0.5 :: it means field is only in X-direction, and so the only choice for pulling too
        gradientFieldVolt[0] = saturationGradientFieldVolt;
        //  printf("Saturated +X1 \n");
    }
    if (gradientFieldVolt[0] < -saturationGradientFieldVolt) {// to avoid singularities in X  default constant 0.5 :: it means field is only in X-direction, and so the only choice for pulling too
        gradientFieldVolt[0] = -saturationGradientFieldVolt;
        //  printf("Saturated -X1 \n");
    }

    if (gradientFieldVolt[1]>saturationGradientFieldVolt) // to avoid singularities in X  default constant 0.5 :: it means field is only in X-direction, and so the only choice for pulling too
    {
        gradientFieldVolt[1] = saturationGradientFieldVolt;
        // printf("Saturated +X2 \n");
    }
    if (gradientFieldVolt[1]<-saturationGradientFieldVolt) // to avoid singularities in X  default constant 0.5 :: it means field is only in X-direction, and so the only choice for pulling too
    {
        gradientFieldVolt[1] = -saturationGradientFieldVolt;
        //  printf("Saturated -X2 \n");
    }
    if (gradientFieldVolt[2] > saturationGradientFieldVolt) { // to avoid singularities in X  default constant 0.5 :: it means field is only in X-direction, and so the only choice for pulling too
        gradientFieldVolt[2] = saturationGradientFieldVolt;
        // printf("Saturated +Y1 \n");
    }
    if (gradientFieldVolt[2] < -saturationGradientFieldVolt) { // to avoid singularities in X  default constant 0.5 :: it means field is only in X-direction, and so the only choice for pulling too
        gradientFieldVolt[2] = -saturationGradientFieldVolt;
        // printf("Saturated -Y1 \n");
    }

    if (gradientFieldVolt[3] > saturationGradientFieldVolt) { // to avoid singularities in X  default constant 0.5 :: it means field is only in X-direction, and so the only choice for pulling too
        gradientFieldVolt[3] = saturationGradientFieldVolt;
        // printf("Saturated +Y2 \n");
    }
    if (gradientFieldVolt[3] < -saturationGradientFieldVolt) { // to avoid singularities in X  default constant 0.5 :: it means field is only in X-direction, and so the only choice for pulling too
        gradientFieldVolt[3] = -saturationGradientFieldVolt;
        // printf("Saturated -Y2 \n");
    }
    return 1;
}

static int add_constant_and_gradient_field_signal () {
    int reversal = get_reverse();
    if(reversal_override) reversal = 1; // Robot backs up at last stage of autonomy
    if (gradientFieldVolt[0] >= 0) {
        outputVolt[0] = (1-reversal)*gradientFieldVolt[0];
        outputVolt[1] = reversal*gradientFieldVolt[1];
    } else {
        outputVolt[0] = reversal*gradientFieldVolt[0];
        outputVolt[1] = (1-reversal)*gradientFieldVolt[1];
    }

    if (gradientFieldVolt[2] >= 0) {
        outputVolt[3] = (1-reversal)*gradientFieldVolt[3];
        outputVolt[2] = reversal*gradientFieldVolt[2];
    } else {
        outputVolt[3] = reversal*gradientFieldVolt[3];
        outputVolt[2] = (1-reversal)*gradientFieldVolt[2];
    }

    outputVolt[4] = uniformFieldVolt[4];
    outputVolt[5] = uniformFieldVolt[5];

    return 1;
}

/* Create obstacles where arena boundaries are */
static void create_og (int** &occ_grid, Point points[], int thickness, float** cargo_pos, float radius) {
    int x_avg = points[2].x;
    printf("Point y: (%d,%d)\n", points[0].y, points[1].y);
    for ( int i = points[0].y; i <= points[1].y; i++ ){ // Draw 0s on left wall
        // printf("i: %d\n", i);
        for(int j = points[0].x-thickness/2; j < points[0].x+thickness/2; j++){ // Add thickness to walls
            printf("Changed pos 1: (%d,%d)\n", i,j);
            occ_grid[i][j] = 0;
        }
    }

    for ( int i = points[0].x; i <= points[1].x; i++ ) { // Draw 0s on bottom wall
        for(int j = points[1].y-thickness/2; j < points[1].y+thickness/2; j++){ // Add thickness to walls
            // printf("Changed pos: (%d,%d)\n", i,j);
            occ_grid[j][i] = 0;
        }
    }

    for(int i = points[0].y; i <= points[1].y; i++){ // Draw 0s on right wall
        for(int j = points[1].x-thickness/2; j < points[1].x+thickness/2; j++){ // Add thickness to walls
            // printf("Changed pos: (%d,%d)\n", i,j);
            occ_grid[i][j] = 0;
        }
    }

    for(int i = points[1].x; i >= points[0].x; i--){ // Draw 0s on top wall
        for(int j = points[0].y-thickness/2; j < points[0].y+thickness/2; j++){ // Add thickness to walls
            // printf("Changed pos: (%d,%d)\n", i,j);
            occ_grid[j][i] = 0;
        }
    }

    for(int i = points[0].y; i <= points[3].y; i++){ // Draw 0s on center wall
        for(int j = x_avg - thickness/2; j < x_avg + thickness/2; j++){ // Add thickness to walls
            // printf("Changed pos: (%d,%d)\n", i,j);
            occ_grid[i][j] = 0;
        }
    }

    for(int i = points[4].y; i <= points[5].y; i++){ // Draw 0s on center wall
        for(int j = x_avg - thickness/2; j < x_avg + thickness/2; j++){ // Add thickness to walls
            // printf("Changed pos: (%d,%d)\n", i,j);
            occ_grid[i][j] = 0;
        }
    }

    // Create obstacles where cargo is
    for(int i = cargo_pos[0][0]-radius; i < cargo_pos[0][0]+radius; i++){
        for(int j = cargo_pos[0][1] - radius; j < cargo_pos[0][1] + radius; j++){
            // printf("Changed pos: (%d,%d)\n", i,j);
            occ_grid[j][i] = 0;
        }
    }
}


void calc_clickPos(float* robot_pos, Pair next_pos, float look_ahead, float* click_pos){
    // Calculate updated mouse position for each node in Path
    float heading = atan2(next_pos.first - robot_pos[1], next_pos.second - robot_pos[0]);
    click_pos[0] = next_pos.second + look_ahead*cos(heading);
    click_pos[1] = next_pos.first + look_ahead*sin(heading);
}

/* note the argument carg_pos is not used */
static void calc_dest (float** carg_pos, float tol, Pair &dest) {
    // Calculate actual destination that the robot shoulds go towards based on cargo's radius
    float heading = cargo_pos[0][2];
    dest.second = cargo_pos[0][0] - tol*sin(cargo_pos[0][2]);
    dest.first  = cargo_pos[0][1] - tol*cos(cargo_pos[0][2]);
}

void on_botcoorX_changed (GtkEditable *editable, gpointer user_data){
    botCoorX = int(gtk_spin_button_get_value(GTK_SPIN_BUTTON(editable)));
}

void on_botcoorY_changed (GtkEditable *editable, gpointer user_data){
    botCoorY = int(gtk_spin_button_get_value(GTK_SPIN_BUTTON(editable)));
}

void on_leftcoorX_changed (GtkEditable *editable, gpointer user_data){
    leftCoorX = int(gtk_spin_button_get_value(GTK_SPIN_BUTTON(editable)));
}

void on_leftcoorY_changed (GtkEditable *editable, gpointer user_data){
    leftCoorY = int(gtk_spin_button_get_value(GTK_SPIN_BUTTON(editable)));
}

void on_finalcoorX_changed (GtkEditable *editable, gpointer user_data){
    finalCoorX = int(gtk_spin_button_get_value(GTK_SPIN_BUTTON(editable)));
}

void on_finalcoorY_changed (GtkEditable *editable, gpointer user_data){
    finalCoorY = int(gtk_spin_button_get_value(GTK_SPIN_BUTTON(editable)));
}

////////   MMC functions that run after interacting with GUI  //////
int setPgain_MMC(float d) { // Set P gain
    PgainMMC = d;
    return 1;
}

////////   MMC functions that run after interacting with GUI  //////
int setIgain_MMC(float d) { // Set I gain
    IgainMMC = d;
    return 1;
}

////////   MMC functions that run after interacting with GUI  //////
int setDgain_MMC(float d) { // Set D gain
    DgainMMC = d;
    return 1;
}

/* main thread */
static void * autonomy_thread ( void * threadid ) {
    cargo_pos[0] = get_cargo_pose();
    cargo_pos_prevX = cargo_pos[0][0]; cargo_pos_prevY = cargo_pos[0][1];

    // Pulling thread
    printf("MMC_thread started\n");
    init_amp(); // Turn on amplifiers (amplifier.cpp)

    printf("Test 1\n");

    float globalFieldAngle = 0.0, globalFieldAngleMemo = 0.0;     // output field angle for constant field and its memory
    float pull_const=0, int_const=0, der_const=0, errorPull=0, errorPullPrev=0, errorPos = 0, errorSum=0,\
          errorDiff=0, COM_coorX=0, COM_coorY=0, GOAL_coorX=0, GOAL_coorY=0, CLICK_coorX=0, CLICK_coorY=0;

    double pulling_angle=0;
    float periodTime = 1.0 / freq;  // time per period

    double startTime = 0, presentTime = 0, timeElapsed = 0; // Time variables
    startTime = get_present_time ();                        // general_fun.cpp
    float outputVZ = 0; // Output z axis voltage

    // Path Planning Variables
    Pair src; // Current start location of robot
    Pair dest; // Current goal location of robot
    Pair next_pos; // Next location in stack that robot should move towards
    // stack<Pair> Path; // Stack of positions to be generated by A*

    // Create Occupancy Grid based on arena and cargo (These variables should come from CV)
    float radius = 10; // Size of cargo (to be approximated as a square for occupancy grid)
    Point points[num_points];
    points[0].x = 142; points[0].y = 132; // Boundary corner points
    points[1].x = 513; points[1].y = 350;
    points[2].x = 325; points[2].y = 132; // Walls
    points[3].x = 325; points[3].y = 164;
    points[4].x = 325; points[4].y = 196;
    points[5].x = 325; points[5].y = 260;

    // Run the main MMC thread (after clicking Start Control)
    while ( MMCThread ) {
        if(get_stop()) break;

        // printf("Reverse: %d\n", get_reverse());
        // printf("Still in the MMC Thread\n");
        // printf("Open CV Version: %s\r\n", CV_VERSION);
        // printf("Executing task \n");
        robot_pos[0] = get_robot_pose(); // Get updated coordinates of robot in image frame (vision.cpp)
        cargo_pos[0] = get_cargo_pose(); // Get mouse key goal point in image frame
        goal_pos[0] = getGoalPointCoor(); // Initialize goal variable to avoid seg faults
        click_pos[0] = getGoalPointCoor(); // Initialize clicked position in image

        printf("cargo_pos: (%f,%f)\n", cargo_pos[0][0], cargo_pos[0][1]);
        printf("cargo_pos_prev: (%f,%f)\n", cargo_pos_prevX, cargo_pos_prevY);

        dist_cargo_iteration = sqrt(pow(cargo_pos_prevX - cargo_pos[0][0], 2) + pow(cargo_pos_prevY - cargo_pos[0][1], 2));
        if(dist_cargo_iteration > thresh_cargo){
            printf("False cargo detected\n");
            cargo_pos[0][0] = cargo_pos_prevX;
            cargo_pos[0][1] = cargo_pos_prevY;
        }
        // cargo_pos_prev[0][0] = cargo_pos[0][0]; cargo_pos_prev[0][1] = cargo_pos[0][1];
        cargo_pos_prevX = cargo_pos[0][0]; cargo_pos_prevY = cargo_pos[0][1];

        // printf("robot_pos: (%d,%d)\n", (int)robot_pos[0][0], (int)robot_pos[0][1]);
        // printf("cargo_pos: (%d,%d)\n", (int)cargo_pos[0][0], (int)cargo_pos[0][1]);
        draw_x = (int)robot_pos[0][0]; draw_y = (int)robot_pos[0][1];

        // Basic code simply moves the robot down, left, and up assuming it grabs cargo
        if(autonomous){
            if(basic){
                if(state == -1){ // Mount to cargo
                    heading = atan2(cargo_pos[0][1] - robot_pos[0][1], cargo_pos[0][0] - robot_pos[0][0]);
                    REF_coorX = cargo_pos[0][0] + offset_cargo*cos(heading);
                    REF_coorY = cargo_pos[0][1] + offset_cargo*sin(heading);
                    if(sqrt(pow(robot_pos[0][0] - cargo_pos[0][0], 2) + pow(robot_pos[0][1] - cargo_pos[0][1], 2)) < thresh_mount){
                        state += 1;
                        REF_coorX = robot_pos[0][0];
                        REF_coorY = botCoorY - offsetBotY;
                        continue;
                    }
                }else if(state == 0){ // Go to bottom of arena
                    if(sqrt(pow(robot_pos[0][0] - REF_coorX, 2) + pow(robot_pos[0][1] - REF_coorY, 2)) < thresh_bot){
                        state += 1;
                        REF_coorX = leftCoorX; REF_coorY = leftCoorY;
                        continue;
                    }
                }else if(state == 1){ // Go to left of arena
                    if(sqrt(pow(robot_pos[0][0] - REF_coorX, 2) + pow(robot_pos[0][1] - REF_coorY, 2)) < thresh_left){
                        state += 1;
                        REF_coorX = finalCoorX; REF_coorY = finalCoorY;
                    }
                }else if(state == 2){ // Go to final position of arena
                    if(sqrt(pow(robot_pos[0][0] - REF_coorX, 2) + pow(robot_pos[0][1] - REF_coorY, 2)) < thresh_left){
                        state += 1;
                        reversal_override = 1;
                        REF_coorX = finalCoorX + 100; REF_coorY = finalCoorY;
                    }
                }else if(state == 3){ // Rotate cargo to correct pose and back up
                    if(sqrt(pow(robot_pos[0][0] - REF_coorX, 2) + pow(robot_pos[0][1] - REF_coorY, 2)) > thresh_backup){
                        state = -1;
                        reversal_override = 0;
                        break;
                    }
                }
            }else if(state == -1 || state == 4){ // Calibration phase, get arena boundary points and occupancy grid
                create_og(occ_grid, points, thickness, cargo_pos, radius);
                printf("Occupancy Grid: %d\n", occ_grid[132][325]);

                // Set source and destination of path that robot should traverse
                src  = make_pair ((int)robot_pos[0][1],(int)robot_pos[0][0]);
                dest = make_pair ((int)cargo_pos[0][1],(int)cargo_pos[0][0]);
                calc_dest(cargo_pos, tol, dest); // Update detination based on cargo's pose

                printf("src: (%d,%d)\n", src.second, src.first);
                printf("dest: (%d,%d)\n", dest.second, dest.first);

                // printf("src: (%d,%d), dest: (%d,%d)\n", src.first,src.second,dest.first,dest.second);
                aStarSearch(occ_grid, src, dest, Path); // Run A* and generate Path
                Path_vision = Path; // Copy updated path for vision code to display

                Path.pop(); // Get rid of first element since the robot starts here

                // Free memory allocated for occ_grid
                for(int i = 0; i < ROW; ++i) {
                    delete [] occ_grid[i];
                }
                delete [] occ_grid;

                state += 1; // Go to next state
            } else if (state == 0 || state == 5){ // Extract next position to go to from Path
                printf("REACHED STATE 0: GOING TO NEXT PATH NODE\n");
                if(Path.empty()){ // Reached destination in path
                    printf("PATH COMPLETE\n");
                    state = 2; // Signifies end of current path
                    continue;
                }
                next_pos = Path.top(); Path.pop(); // Extract next postion to go to
                calc_clickPos(robot_pos[0], next_pos, look_ahead, click_pos[0]); // Compute next position to click
                fVibrate = 1; // Vibrate to let robot move

                printf("Going to next position: (%d,%d) by clicking here: (%f,%f)\n",\
                       next_pos.second,next_pos.first,click_pos[0][0], click_pos[0][1]);
                state = 1;
            } else if (state == 1 || state == 6){ // Move towards current waypoint
                if(errorPos < thresh){ // Check if robot's current position is near the next one on the path
                    state = 7;
                    continue;
                }
                printf("Still going to next dest: (%d,%d), currently at (%f,%f), clicking (%f, %f)\n", \
                       next_pos.second, next_pos.first, robot_pos[0][0], robot_pos[0][1], click_pos[0][0], click_pos[0][1]);
            } else if (state == 2 || state == 7){ // Turn towards cargo and set position such that robot will move towards cargo
                final_ang = state == 2 ? cargo_pos[0][2] : desired_ang; // Either set angle of alignment to cargo's orientation or goal orientation based on state
                if(abs(final_ang - robot_pos[0][2]) > max_angdiff){
                    next_ang = robot_pos[0][2] + max_angdiff; // Take one rotation step towards cargo
                }else{
                    next_ang = cargo_pos[0][2]; // Set next angle to cargo's angle
                    click_pos[0][0] = cargo_pos[0][0] + look_ahead*cos(cargo_pos[0][2]); // Set goal position slightly ahead of cargo position for state 3
                    click_pos[0][0] = cargo_pos[0][0] + look_ahead*sin(cargo_pos[0][2]);
                    state += 1; // Assume we align to the cargo immediately, so we move on to the next state
                }
                click_pos[0][0] = robot_pos[0][0] + look_ahead*cos(next_ang); // Dummy goal position so that robot orients towards cargo
                click_pos[0][1] = robot_pos[0][1] + look_ahead*sin(next_ang);
                fVibrate = 0; // No need to vibrate when just aligning to goal pose
                usleep(2000); // Give 2s for the microrobot to orient
            }else if(state == 3){ // Go towards cargo
                // globalFieldAngle = pulling_angle;
                fVibrate = 1; // Vibrate to let robot move
                if(errorPull < thresh){
                    state = 4;
                }
            }else if(state == 4){ // Go towards goal
                // globalFieldAngle = pulling_angle;
                goal_pos[0] = getGoalPointCoor(); // Final goal is wherever the mouse clicks
                fVibrate = 1; // Vibrate to let robot move
                if(errorPull < thresh){
                    state = 4;
                }
            }else if(state == 4){ // Align to proper orientation
                // globalFieldAngle = goal_orientation; // Align to cargo
                goal_pos[0][0] = robot_pos[0][0] + cos(cargo_pos[0][2]); // Dummy goal position so that robot orients towards cargo
                goal_pos[0][1] = robot_pos[0][1] + sin(cargo_pos[0][2]);
                fVibrate = 0; // No need to vibrate when just aligning to goal pose
                usleep(2000); // Give 2s for the microrobot to orient
                MMCThread = 0; // Break out of while loop
            }else if(state == 8){ // Done
                break;
            }
        }else{ // Manual mode --> click around to move the robot
            click_pos[0] = getGoalPointCoor(); // Use for positioning robot wherever the mouse clicks
            REF_coorX = click_pos[0][0];
            REF_coorY = click_pos[0][1];
            // printf("%f,%f\n",goal_pos[0][0], goal_pos[0][1]);
        }

        // Waypoint following based on current path node
        COM_coorX = robot_pos[0][0]; // Current location of robot
        COM_coorY = robot_pos[0][1];

        //FOR MANUAL CLICKING USE
        CLICK_coorX = click_pos[0][0]; // Next location of robot based on click position
        CLICK_coorY = click_pos[0][1];

        // FOR AUTONOMOUS USE
        // CLICK_coorX = cargo_pos[0][0]; // Next location of robot based on cargo position (only used for test purposes, not actual competition)
        // CLICK_coorY = cargo_pos[0][1];
        click_x = CLICK_coorX; click_y = CLICK_coorY;
        GOAL_coorX = next_pos.second;
        GOAL_coorY = next_pos.first;

        // PID Controller calculations
        errorPos = sqrt(pow(GOAL_coorX - COM_coorX, 2) + pow(GOAL_coorY - COM_coorY, 2)); // Error term for path planner
        errorPullPrev = errorPull; // Keep track of previous error for derivative computation

        errorPull = sqrt(pow(REF_coorX - COM_coorX, 2) + pow(REF_coorY - COM_coorY, 2)); // Error term for PID controller
        errorSum = errorSum + errorPull; // Approximate integral of error
        errorDiff = errorPull - errorPullPrev; // Approximate derivative of error
        pulling_angle = atan2((float)(REF_coorY - COM_coorY), (float)(REF_coorX - COM_coorX));
        // printf("(X,Y) = (%f, %f),  (E1,E2) = (%f, %f)\n",COM_coorX, COM_coorY, errorPull, pulling_angle); // Debug statement

        // PID control
        pull_const = 1e-2 * PgainMMC * errorPull; // Proportional term
        int_const = 1e-2 * IgainMMC * errorSum; // Integral term
        der_const = 1e-2 * DgainMMC * errorDiff; // Derivative term

        // Use Gradient Field Method with Lucas' coils (these values are percentages of full voltage)
        gradientFieldVolt[0] = -0.5*(pull_const+int_const+der_const) * cos(pulling_angle) / (Coilpair_ratio_MA*1.9); // Inner coils (Y)
        gradientFieldVolt[1] = -0.5*(pull_const+int_const+der_const) * cos(pulling_angle) / (Coilpair_ratio_MA*1.9);
        gradientFieldVolt[2] = -0.5*(pull_const+int_const+der_const) * sin(pulling_angle) / (Coilpair_ratio_MA*1.3); // Middle coils (X)
        gradientFieldVolt[3] = -0.5*(pull_const+int_const+der_const) * sin(pulling_angle) / (Coilpair_ratio_MA*1.3);

        // Use Uniform Field with Stick Slip Method
        // uniformFieldVolt[0] = B_strength_MA * cos(globalFieldAngle) / 5.32;         // x-left
        // uniformFieldVolt[1] = B_strength_MA * cos(globalFieldAngle) / 5.32;         // x-right
        // uniformFieldVolt[2] = B_strength_MA * sin(globalFieldAngle) / 5.2;          // y-left
        // uniformFieldVolt[3] = B_strength_MA * sin(globalFieldAngle) / 5.2;          // y-right

        // Create stick slip motion with varying z coil actuation
        presentTime = get_present_time ();
        timeElapsed = presentTime - startTime;
        if(timeElapsed >= periodTime){
            timeElapsed = timeElapsed - periodTime*(int)((presentTime - startTime)/periodTime); // Bring timeElapsed into period range
            startTime = presentTime - timeElapsed;
        }

        outputVZ = -1.0 * ampZ * timeElapsed / periodTime;         // make the object tail tilt up
        // printf("AmpZ: %.2f, Time Elapsed: %.2f, Period Time: %.2f\n", ampZ, timeElapsed, periodTime);
        // uniformFieldVolt[4] = outputVZ; // Set z axis voltages
        // uniformFieldVolt[5] = outputVZ;

        // Z Field Lucas' coils
        uniformFieldVolt[4] = outputVZ*10; // Set z axis voltages
        uniformFieldVolt[5] = outputVZ*10;

        // Z Field Lucas' coils turn off
        // uniformFieldVolt[4] = 0;
        // uniformFieldVolt[5] = 0;

        // Debug print statements
        // printf("Click position: (%f, %f)\n", click_pos[0][0], click_pos[0][1]);
        // printf("Robot position: (%f, %f)\n", robot_pos[0][0], robot_pos[0][1]);
        // printf("Cargo position: (%f, %f)\n", cargo_pos[0][0], cargo_pos[0][1]);

        // Actuate coils (Lucas' coils)
        add_constant_and_gradient_field_signal(); // Add gradient and uniform field
        run_amp(outputVolt);
        usleep(3e3);

        // Visualization of occupancy grid and path
        // draw_goal(&img_m_color_for_display);
    }

    // Finish MMC thread and turn off all coils
    printf("Stopping\n");
    stop_amp();
    printf("MMC_thread ended\n");
}

/* start/stop automatic control thread */
void on_tB_actuation_toggled (GtkToggleButton *togglebutton, gpointer data) {
    int d = gtk_toggle_button_get_active (togglebutton);
    if (d == 1) {
        printf("MMC path planning started!\n");
        stopped = 0;
        MMCThread = 1;
        pthread_t MMC_Thread;
        pthread_create ( &MMC_Thread, NULL, autonomy_thread, NULL );
    } else {
        MMCThread = 0;
        stop_amp(); // Lucas stop amp
    }
}

void on_autonomy_toggled(GtkToggleButton *togglebutton, gpointer data){
    int d = gtk_toggle_button_get_active (togglebutton);
    if(d == 1){
        autonomous = 1;
    }else{
        autonomous = 0;
    }
}
