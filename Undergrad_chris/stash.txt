diff --git a/Undergrad_chris/Makefile b/Undergrad_chris/Makefile
index 22ede38..c10fb40 100644
--- a/Undergrad_chris/Makefile
+++ b/Undergrad_chris/Makefile
@@ -13,7 +13,7 @@ tutorial: main.c callbacks.c callbacks.h vision.c s826_subroutine.c FWcamera.cpp
 #	gcc -std=gnu99 `pkg-config --cflags gtk+-3.0` -o tutorial main.c callbacks.c pololu.c s826_subroutine.c vision.c -export-dynamic `pkg-config --libs gtk+-3.0` -lm `pkg-config --cflags --libs opencv --libs l826_64 `
 #best	gcc -std=gnu99 `pkg-config --cflags gtk+-2.0` -o tutorial main.c callbacks.c pololu.c vision.c s826_subroutine.c -export-dynamic `pkg-config --libs gtk+-2.0` -lm `pkg-config --cflags --libs opencv --libs l826_64`
 #	g++ -std=c++0x `pkg-config --cflags gtk+-2.0` -o tutorial main.c callbacks.c pololu.c vision.c s826_subroutine.c motorControl.c quadstep.cpp FWcamera.cpp -export-dynamic `pkg-config --libs gtk+-2.0` -lm `pkg-config --cflags --libs opencv --libs` -l826_64  -lraw1394 -ldc1394
-	${CXX} ${FLAGS} -std=c++0x `pkg-config --cflags gtk+-2.0` -o tutorial main.c callbacks.c vision.c s826_subroutine.c math_subroutine.c PageGeneralControl.c Amplifier.c  PageTwistField.c undergrad.cpp astar.cpp FWcamera.cpp classDefJZ.cpp -export-dynamic `pkg-config --libs gtk+-2.0` -lm `pkg-config --cflags --libs opencv --libs`  -lraw1394 -ldc1394
+	${CXX} ${FLAGS} -std=c++0x `pkg-config --cflags gtk+-2.0` -o tutorial main.c callbacks.c vision.c s826_subroutine.c math_subroutine.c PageGeneralControl.c Amplifier.c  PageTwistField.c undergrad.cpp astar.cpp FWcamera.cpp classDefJZ.cpp -export-dynamic `pkg-config --libs gtk+-2.0` -lm `pkg-config --cflags --libs opencv --libs`  -lraw1394 -ldc1394 -lNETUSBCAM
 #	gcc -std=gnu99 `pkg-config --cflags gtk+-2.0` -o main.c callbacks.c pololu.c -export-dynamic `pkg-config --libs gtk+-2.0` -lm `pkg-config --cflags --libs opencv --libs l826_64`
 #	gpp -std=c++0x `pkg-config --cflags gtk+-2.0` -o vision.c s826_subroutine.c -export-dynamic `pkg-config --libs gtk+-2.0` -lm `pkg-config --cflags --libs opencv --libs l826_64`
 #	gpp -o tutorial main.o callbacks.o pololu.o vision.o s826_subroutine.o
diff --git a/Undergrad_chris/classDefJZ.h b/Undergrad_chris/classDefJZ.h
index 91b7539..e03b440 100644
--- a/Undergrad_chris/classDefJZ.h
+++ b/Undergrad_chris/classDefJZ.h
@@ -6,6 +6,10 @@
 #include <opencv/highgui.h>
 #include "s826_subroutine.h"
 
+#include "opencv2/objdetect.hpp"
+#include "opencv2/highgui.hpp"
+#include "opencv2/imgproc.hpp"
+
 class Point_JZ {
     public:
         Point_JZ (void);
@@ -57,7 +61,7 @@ class Image_JZ {
         cv::Mat img;
         cv::Mat processedImg;
         cv::Mat contourImg;
-        cv::vector<cv::vector<cv::Point> > 	contours;
+        std::vector<std::vector<cv::Point> > 	contours;
         int agentIndex[4];                                  // index of detected agent in contours (maximum 4)
 };
 
diff --git a/Undergrad_chris/tutorial b/Undergrad_chris/tutorial
deleted file mode 100755
index ca27104..0000000
Binary files a/Undergrad_chris/tutorial and /dev/null differ
diff --git a/Undergrad_chris/undergrad.cpp b/Undergrad_chris/undergrad.cpp
index 6c0bd66..27ee958 100644
--- a/Undergrad_chris/undergrad.cpp
+++ b/Undergrad_chris/undergrad.cpp
@@ -26,7 +26,7 @@ static int uniform_on = 0; // 0 means uniform field is on
 static float thresh = 2.0; // Distance in pixels that center of mass of robot can be from goal location
 static bool autonomous = 0; // IMPORTANT Flag for whether robot should follow autonomous path or just go wherever the mouse click tells it to
 static bool mountable = 0; // Flag for when the robot is able to mount to the cargo
-static int state = -1; // 
+static int state = -1; //
 static float goal_orientation; // Goal orientation that the cargo should take on
 static float freq = 10;                // frequency of vibration
 static int num_points = 6; // Number of points required for calibration
@@ -148,6 +148,7 @@ static int output_signal_to_amplifier (void) {
 static void* autonomy_thread(void * threadid){
     // Pulling thread
     printf("MMC_thread started\n");
+    printf("Open CV Version: %s\r\n", CV_VERSION);
 
     float globalFieldAngle = 0.0, globalFieldAngleMemo = 0.0;                   // output field angle for constant field and its memory
     float pull_const=0, int_const=0, der_const=0, errorPull=0, errorPullPrev=0, errorPos = 0, errorSum=0,\
@@ -303,6 +304,8 @@ static void* autonomy_thread(void * threadid){
         gradientFieldVolt[2] = (pull_const+int_const+der_const) * sin(pulling_angle) / (Coilpair_ratio_MA*20); // Inner coils
         gradientFieldVolt[3] = (pull_const+int_const+der_const) * sin(pulling_angle) / (Coilpair_ratio_MA*20);
 
+        printf("Gradient Field: %f\n", gradientFieldVolt[0]);
+
         // Use Uniform Field with Stick Slip Method
         // uniformFieldVolt[0] = B_strength_MA * cos(globalFieldAngle) / 5.32;         // x-left
         // uniformFieldVolt[1] = B_strength_MA * cos(globalFieldAngle) / 5.32;         // x-right
diff --git a/Undergrad_chris/vision.c b/Undergrad_chris/vision.c
index 69c7cea..1eff1a8 100644
--- a/Undergrad_chris/vision.c
+++ b/Undergrad_chris/vision.c
@@ -1,780 +1,273 @@
-////////////////////////////////////////////////////////////////////////////////////////
-// File      : vision.c
-// Function  : Image processing and drawing. initialize camera, receive and display frames, process images
-// Edited by : Jiachen, Zhe
-////////////////////////////////////////////////////////////////////////////////////////
 #include "opencv2/opencv.hpp"
 #include <iostream>
 #include <stdio.h>
 #include <vector>
-#include <iostream>
 #include <string.h>
 #include "general_header.hpp"
+#include "NETUSBCAM_API.h"
+#include "ICubeDefines.h"
+#include <unistd.h>
+#include <signal.h>
 #include "vision.h"
 
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-// Variables
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-FWcamera cam, cam_xz; //see FWcamera.cpp
-
-int width = 640;   //image width, pixels
-int height = 480;  //image height, pixels
-int depth = 1;     //depth of image
-//unsigned char * image = NULL;
-int killVisionThread = 1; //this stops our vision thread
-
-GtkLabel *labelFPSreceive, *labelFPSreceive_xz;
-
-static Point mouse, mouseC, mouseR;
-static Point mouse_xz, mouseC_xz, mouseR_xz;
-
-
-// Chris's global vision parameters
-static Image_JZ presFrame;                                      // present obtained frame
-static Point_JZ cargoOne(0,0);                  				 // cargo detected from frames
-static Point_JZ cargoOneMemo(0,0);           					// cargo memories
-static Point agentOne(0,0);             						 // first agent center recoreded variable
-static Point agentOneMemo(0,0);                      	        // memory of 2 agents, used to avoid switching
-static float r_x = 10;
-static float r_y = 10;
-static float centerPointCoorArray[2]  = {320, 240};
-static float centerPointCoorArray_2[3]  = {320, 140, 0}; // Current pose of cargo
-static float goalPointCoorArray[2]   = {320, 240};
-Point centerP_adjusted, centerP_adjusted_xz;
-Point centerP_adjusted_2;
-
-static float r_angle; //this is the actual robot angle
-static float c_x;
-static float c_y;
-static float c_r;
-
-static int centerP_dataSafeLock = 0;  // 1: centerP is being changed, wait until it is done
-
-int binaryThreshold = 90;                   // indicating the level of binary conversion.
-int Hough_Erosion_adj = 0;                  //for processing. Used in houghCircle() indicating the level of erosion conversion.
-int Hough_dilation_adj = 6;                 //for processing. Used in houghCircle() indicating the level of dilation conversion.
-int setBlursizeHough = 10;          // set Blur size in Hough transform                put 7 if you are using Median filter otherwise 16 to 25 is good
-
-// X-Y Camera
-int cannyLow = 100, cannyHigh = 150; //thresholds for image processing filter
-static int dilater = 1;
-static int edgemap = 0, binary = 0; //are we performing edgemap calculations?
-int visionParam2 = 35; //for processing
-static int flag3dIndicator = 0, flag2dIndicator = 1;
-
-static float fpsReceive; //frames per second of video
-Mat img_m_color_for_display;
-
-// X-Z Camera
-int cannyLow_xz=100, cannyHigh_xz=150;
-static int dilater_xz = 1;
-static int edgemap_xz = 0, binary_xz = 0;
-static int binaryThreshold_xz = 65;
-int visionParam2_xz = 35;
-static int flag3dIndicatorXZ = 1, flag2dIndicatorXZ = 1;
-static int topcam_on = 1; //is the sidecam capturing? Default: YES
-static float fpsReceive_xz;
-Mat img_m_color_for_display2;
-
-// Digital arena variables
-static float scaleX = 210;
-static float scaleY = 190;
-static float wall_width = 2.5*scaleY;
-static float wall_length = 3*scaleX;
-static float bound_length = 0.4*scaleY;
-static float bound_gap = 0.4*scaleY;
-
-// magnet detection variables -- Zhe
-float m_x, m_y, m_a = 0.0, m_x_history[6] = {0,0,0,0,0,0}, m_y_history[6] = {0,0,0,0,0,0}, m_a_history[6] = {0,0,0,0,0,0}; // historical value of magnet centre (m_x, m_y) and angle m_a
-// float m_x_temp, m_y_temp, m_a_temp;
-float magnet_area = 0;
-float trust_area = 0;
-bool flag_magnet_sampled = false;
-float Mwidth, Mlength;
-// extern float fangle, destination_angle, v1, v2;
-// extern float current_temp;
-// extern char fab_status[];
-// extern char fab_time[];
-// extern float field_x, field_y, field_z, field_mag, field_angle;
-
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-// Global Functions
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-Mat getImage(void) {
-	return img_m_color_for_display;
-}
+#include "opencv2/objdetect.hpp"
+#include "opencv2/highgui.hpp"
+#include "opencv2/imgproc.hpp"
+
+//Read: usable variables: Robot: r_x,r_y,r_angle; Cargo: c_x,c_y
+
+//~/Desktop/Undergraduate_Thesis/York$ g++ `pkg-config --cflags gtk+-3.0` `pkg-config --cflags opencv` -o test test.cpp `pkg-config --libs opencv` `pkg-config --libs gtk+-3.0` -lNETUSBCAM
+//g++ -o test test.cpp `pkg-config --libs gtk+-3.vision0` `pkg-config --cflags --libs opencv --libs` -lNETUSBCAM
+//~/Desktop/Undergraduate_Thesis/York$ ./test
+
+using namespace std;
+using namespace cv;
 
-Mat getImage2(void) {
-	return img_m_color_for_display2;
-}
 
-// York's contour function
+Mat camera;
+int killVisionThread = 1;
+
 bool compareContourAreas ( vector<Point> contour1, vector<Point> contour2 ) {
     double i = fabs( contourArea(Mat(contour1)) );
     double j = fabs( contourArea(Mat(contour2)) );
     return ( i < j );
 }
 
-float *get_robot_pose(void){
-	//	int *centerPointCoorArray  = (int*) malloc(2*sizeof(int));
-	//	printf("TEST1\n");
-	while(centerP_dataSafeLock);                   // wait until change is done
-		centerP_dataSafeLock = 1;
-	    centerPointCoorArray[0] = r_x; // Set to global variables
-	    centerPointCoorArray[1] =  r_y;   // do not forget 480 offset
-		centerPointCoorArray[2] = r_angle; // Set to global angle variable
-		centerP_dataSafeLock = 0;
-		// printf("x= %f, y= %f", centerPointCoorArray[0], centerPointCoorArray[1]);
-
-	    return centerPointCoorArray;
+void SignalHandler(int i)
+{
+   signal(SIGINT, SignalHandler);
 }
 
-float *get_cargo_pose(void){
-	while(centerP_dataSafeLock);                   // wait until change is done
-		centerP_dataSafeLock = 1;
-		centerPointCoorArray_2[0] =  c_x; // Set to global variables
-		centerPointCoorArray_2[1] =  c_y;   // do not forget 480 offset
-		centerPointCoorArray_2[2] = 0; // Set to global angle variable
-		centerP_dataSafeLock = 0;
-		// printf("x= %f, y= %f", centerPointCoorArray[0], centerPointCoorArray[1]);
-
-		return centerPointCoorArray_2;
+int GetImage(void *buffer, unsigned int buffersize, void *context)
+{
+  camera = Mat(1024,1280, CV_8UC3, buffer);
 }
 
-float* getGoalPointCoor(void){
-    if(mouse.x>0){
-        goalPointCoorArray[0] = (float)mouse.x;
-        goalPointCoorArray[1] = (float)(480 - mouse.y);   // Note the positive y dir.
+int ifframe(Mat camera){
+    Size s = camera.size();
+    int rows = s.height;
+    int cols = s.width;
+    if (rows > 0 && cols > 0){
+        return 1;
+    } else{
+        return 0;
     }
-    return goalPointCoorArray;
-}
-
-void initVision(void) {
-		pthread_t vthread, fthread, vthread_xz, fthread_xz;
-		if(!cam_xz.initialize_xz()) {//cam is instance of FWCamera, found in FWcamera.cpp
-				g_print("FW camera xz could not be found in initVision!!!\n");
-				return;
-		}
-		usleep(1e5);
-		if(!cam_xz.startGrabbingVideo_xz()) {
-				g_print("FW cam xz could not grab in initVision!!!\n");
-				return;
-		}
-		if(killVisionThread == 0) {
-				g_print("Vision already running in initVision!!!\n");
-		}
-		usleep(1e5);
-		if(killVisionThread == 1)	{
-		  	killVisionThread = 0;
-				pthread_create(&vthread_xz, NULL, visionThread_xz, NULL);  //start vision thread
-		}
-
-		// X-Y Camera
-		if(topcam_on == 1) {//if we are also using the top cam
-				usleep(2e5);
-				printf("Before cam_xy.initialize_xz().\n");
-				if(!cam.initialize()) {//cam is instance of FWCamera, found in FWcamera.cpp
-						g_print("FW camera xy could not be found in initVision!!!\n");
-						return;
-				}
-				usleep(1e5);
-				if(!cam.startGrabbingVideo())	{
-						g_print("FW cam xy could not grab in initVision!!!\n");
-						return;
-				}
-				usleep(1e5);
-				pthread_create(&vthread, NULL, visionThread, NULL);  //start vision thread
-		}
-		return;
 }
 
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-// Frame Print Thread
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-// This thread is not used? UI still displays images after this is commented out.
-// void* FPSprint(void*)
-// {
-// 	char strReceive[50];
-// 	char strReceive_xz[50];
-//
-// 	while(!killVisionThread)   //while the image processing is running //repeat vision loop until we set killVisionthread=1 using stopVision()
-// 	{
-// 		//  int sprintf(char *str, const char *format, ...) sends formatted output to a string pointed to by str.
-// 		sprintf(strReceive, "%.1f", fpsReceive); //writes into strRecieve the frames per second
-// 		sprintf(strReceive_xz, "%.1f", fpsReceive_xz);
-// 		gdk_threads_enter();
-// 		gtk_label_set_text(GTK_LABEL(labelFPSreceive), strReceive); //draw on the gui
-// 		gtk_label_set_text(GTK_LABEL(labelFPSreceive_xz), strReceive_xz);
-// 		gdk_threads_leave();
-// 		usleep((int)1e6); //sets frame rate display frequency
-// 	}
-// 	//printf("In the test zone!\n");
-// 	sprintf(strReceive, "N/A"); //when we turn off the vision, write N/A into the gui
-// 	sprintf(strReceive_xz, "N/A");
-// 	gdk_threads_enter();
-// 	gtk_label_set_text(GTK_LABEL(labelFPSreceive), strReceive);
-// 	gtk_label_set_text(GTK_LABEL(labelFPSreceive_xz), strReceive_xz);
-// 	gdk_threads_leave();
-// }
-
-
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-// visionThread --- Camera 1
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 void* visionThread(void*) {
 		printf("@ the Beginning of visionThread().\n");
 
-		int index = 0;
-		unsigned char *inImage;																											// = (unsigned char*)malloc(sizeof(unsigned int)*width*height*depth);
-		Mat frame, img_m_color, img_m_gray;
-		Mat threshold_output;    																										// for threshold and rectangle detection
-
-		// Time
-		int i;
-		timeval tStart, tEnd;
-		float time;
-		double current_time;
-		float fpsVec[10] = {10,10,10,10,10,10,10,10,10,10};
-		int fpsIndex = 0;
-		char x_str[5]; char y_str[5]; char ang_str[5];
-
-		int mouse_x_1;
-	    int mouse_y_1;
-	    int mouse_x_2;
-	    int mouse_y_2;
-	    int arena_w=400;//abs(mouse_x_1-mouse_x_2);
-	    int arena_h=300;//abs(mouse_y_1-mouse_y_2);
-	    int occupy[arena_h][arena_w];//the occupy matrix has the size of the arena
-		while(!killVisionThread) {																						//repeat vision loop until we set killVisionthread=1 using stopVision()
-			gettimeofday(&tStart, NULL);
-			//usleep(6e4); 																													//slow down vision thread; this function watis for a new frame, it takes a long time, so we can do some image processing in this thread
-
-			inImage = cam.grabAframe(); 																						//unsigned char *inImage;
-			if(inImage == NULL)	{
-				g_print("Error in firewire stream! Reattempting...\n");
-				usleep((int)1e3); 																										// I don't know what the wait delay should be
-			}
-			frame = Mat(height, width, CV_8UC1, inImage); 													//convert to Mat format
-		    Mat hsv;
-		    Mat mask;
-		    Mat mask2;
-		    vector<vector<Point> > cnts;
-		    vector<vector<Point> > cnts2;
-		    if (frame.empty())
-		      break;
-		    //frame=frame(Rect(0,50,500,400)); //crop the frame
-		    //cvtColor(frame,hsv,COLOR_BGR2GRAY);
-		    inRange(frame,0,60,mask);//lower and upper greyscale threshold for robot
-		    Mat maskfororientation = mask;
-		    erode(mask,mask,Mat(),Point(-1,-1),2);
-		    dilate(mask,mask,Mat(),Point(-1,-1),2);
-			inRange(frame,80,230,mask2);//lower and upper greyscale threshold for cargot
-		    erode(mask2,mask2,Mat(),Point(-1,-1),2);
-		    dilate(mask2,mask2,Mat(),Point(-1,-1),2);
-
-			for (int w=0; w<arena_w; w++){
-		        for (int h=0; h<arena_h; h++){
-		            if (mask.at<int>(h,w)==255){
-		                occupy[h][w]=1; // 1 is robot, 0 is space
-		            }
-		            if (mask2.at<int>(h,w)==255){
-		                occupy[h][w]=2; // 2 is cargo
-		            }
-		        }
-		    }
-
-		    findContours(mask,cnts,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE,Point(0,0));
-			findContours(mask2,cnts2,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE,Point(0,0));
-
-			if ((int)cnts.size()>0){
-				sort(cnts.begin(), cnts.end(),compareContourAreas);
-
-				sort(cnts2.begin(), cnts2.end(),compareContourAreas);
-
-				//printf("size: %d\n", (int)cnts.size());
-				vector<RotatedRect> output(cnts.size());
-
-				for( int i = 0; i < cnts.size(); i++ ){
-					output[i] = minAreaRect(cnts[i]);
-				}
-				float r_x=output[0].center.x;
-				float r_y=output[0].center.y;
-				float r_w=output[0].size.width;
-				float r_h=output[0].size.height;
-
-				drawContours(frame,cnts,0,Scalar(0,0,255),2);
-				putText(frame,"Robot",Point((int)r_x,(int)r_y),FONT_HERSHEY_SIMPLEX,0.5,255,2);
-				Point2f center;
-				float radius;
-				//for( int i = 0; i < cnts2.size(); i++ ){
-				minEnclosingCircle(cnts2[0],center,radius);
-				//}
-				c_x=center.x;
-				c_y=center.y;
-				c_r=radius;
-				circle(frame, Point((int)c_x,(int)c_y), (int)radius, Scalar(0, 255, 0), 2, 8, 0 );
-				putText(frame,"Cargo",Point((int)c_x,(int)c_y),FONT_HERSHEY_SIMPLEX,0.5,255,2);
-
-
-				//get robot angle___________________________________________________________________________
-
-				float tempAngle = output[0].angle;          // get angle of rotated rect
-				int checkPt[8];
-				//printf("angle: %.3f, width: %.3f, height: %.3f\n", tempAngle, width, height);
-				checkPt[0] = r_x - 0.4 * r_w  * cosd(tempAngle);
-				checkPt[1] = r_y - 0.4 * r_h * sind(tempAngle);
-				checkPt[2] = r_x + 0.4 * r_h * sind(tempAngle);
-				checkPt[3] = r_y - 0.4 * r_h * cosd(tempAngle);
-				checkPt[4] = r_x + 0.4 * r_w  * cosd(tempAngle);
-				checkPt[5] = r_y + 0.4 * r_h * sind(tempAngle);
-				checkPt[6] = r_x - 0.4 * r_w  * sind(tempAngle);
-				checkPt[7] = r_y + 0.4 * r_h * cosd(tempAngle);
-
-				float r_angle; //this is the actual robot angle
-				int iDir = -1;
-				if (maskfororientation.at<unsigned char>(checkPt[1],checkPt[0]) == 0){
-					iDir = 0;
-					r_angle=output[0].angle+180;}
-				else if (maskfororientation.at<unsigned char>(checkPt[3],checkPt[2]) == 0){
-					iDir = 1;
-					r_angle=output[0].angle+270;}
-				else if (maskfororientation.at<unsigned char>(checkPt[5],checkPt[4]) == 0){
-					iDir = 2;
-					r_angle=output[0].angle+360;}
-				else if (maskfororientation.at<unsigned char>(checkPt[7],checkPt[6]) == 0){
-					iDir = 3;
-					r_angle=output[0].angle+90;}
-				circle(frame, Point(checkPt[iDir*2], checkPt[iDir*2+1]), 5, Scalar(255,0,0));
-				printf("Robot Angle: %.2f\n",r_angle);
-				//___________________________________________________________________________________
-				// printf("Angle: %.2f\n",r_angle);
-				// printf("X Position: %.2f\n",r_x);
-				// printf("Y Position: %.2f\n",r_y);
-			}
-			else {
-				break;
-			}
-
-				//draw mouse clicks:
-				if(mouse.x>0)
-					circle( img_m_color, mouse, 4, Scalar(  200, 50, 0), 2, 8, 0 );
-
-				img_m_color_for_display = img_m_color;
-
-				//  Needed for Frame rate calculation of Top camera (xy)
-				gettimeofday(&tEnd, NULL);
-				current_time = ((double)tEnd.tv_sec + (double)tEnd.tv_usec*1e-6) ;
-				time = (int)round( (((double)tEnd.tv_sec + (double)tEnd.tv_usec*1e-6) - ((double)tStart.tv_sec + (double)tStart.tv_usec*1e-6) )*1000.0);
-				fpsVec[fpsIndex++] = 1000.0/time;
-				if(fpsIndex > 9) fpsIndex = 0;
-				fpsReceive = 0;
-				for(int i = 0; i < 10; i++)
-				fpsReceive += fpsVec[i];
-				fpsReceive /= 10.0;
-		}																																						//end vision loop due to killVisionthread==1
-		cam.stopGrabbingVideo();
-		usleep ((int)1e5); //make sure that ImageProc_xz has closed
-		cam.deinitialize();
-		printf("@ the End of visionThread().\n");
-		return NULL;
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-// visionThread_xz --- Camera 2   * refer to openCV *
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-void* visionThread_xz(void*) {
-		printf("In vision thread x-z.\n");
-
-		unsigned char *inImage_xz;
-		Mat img_m_xz, img_m_color_xz;
-		Mat threshold_output_xz; //for threshold and rectangle detection
-
-		// Time
-		int i;
-		timeval tStart_xz, tEnd_xz;
-		float time_xz;
-		double current_time_xz;
-		float fpsVec_xz[10] = {10,10,10,10,10,10,10,10,10,10};
-		int fpsIndex_xz = 0;
-
-		// Local variables
-		Mat img_m_xz_ori; // storing the original image of xz
-		Mat img_m_xz_bi;  // storing the binary image of xz
-		Mat img_m_xz_temp;
-		float magnet_maxarea, pre_area = 100.0;
-		int ind_maxarea;
-		bool contour_number = false; // whether the number of contours is greater than 2 ?
-
-		while(!killVisionThread) {																											    //repeat vision loop until we set killVisionthread = 1 using stopVision()
-				gettimeofday(&tStart_xz, NULL);
-				//usleep(6e4); 																																	//slow down vision thread
-
-				inImage_xz = cam_xz.grabAframe_xz(); 																						//unsigned char *inImage;
-				if(inImage_xz == NULL) {
-						g_print("Error in firewire stream xz! Reattempting...\n");
-						usleep((int)1e3); 																													// I don't know what the wait delay should be
-				}
-
-				img_m_xz = Mat(height, width, CV_8UC1, inImage_xz); 														//convert to Mat format
-
-				// opencv image processing
-				if(edgemap_xz == 1) {img_m_xz = opencv_edgemap (img_m_xz.clone(), cannyLow_xz, cannyHigh_xz, dilater_xz);}
-				if(binary_xz == 1) {img_m_xz = opencv_binary (img_m_xz.clone(), binaryThreshold_xz);}
-				cvtColor(img_m_xz, img_m_color_xz, CV_GRAY2BGR); 				//convert to color
-
-				// draw field indicator
-				if (flag2dIndicatorXZ == 1) {draw_xz_magnetic_field(img_m_color_xz,580,400);}
-				if (flag3dIndicatorXZ == 1) {
-					if (currentActiveTabIndex == 1) {
-						draw_3d_magnetic_field_twisted(img_m_color_xz,480,400);
-					}else{
-						draw_3d_magnetic_field(img_m_color_xz,480,400);
-					}
-				}
-
-				img_m_color_for_display2 = img_m_color_xz;
-
-				gettimeofday(&tEnd_xz, NULL);
-				current_time_xz = ((double)tEnd_xz.tv_sec + (double)tEnd_xz.tv_usec*1e-6) ;
-				time_xz = (int)round( (((double)tEnd_xz.tv_sec + (double)tEnd_xz.tv_usec*1e-6) - ((double)tStart_xz.tv_sec + (double)tStart_xz.tv_usec*1e-6) )*1000.0);
-				fpsVec_xz[fpsIndex_xz++] = 1000.0/time_xz;
-				if(fpsIndex_xz > 9) fpsIndex_xz = 0;
-				fpsReceive_xz = 0;
-				for(int i = 0; i < 10; i++)
-				fpsReceive_xz += fpsVec_xz[i];
-				fpsReceive_xz /= 10.0;
-		}																																												//end vision loop due to killVisionthread==1
-		cam_xz.stopGrabbingVideo_xz();
-		usleep ((int)1e5); 																																			//make sure that ImageProc_xz has closed
-		cam.deinitialize(); 																																		//taken care of by top camera deinitialize call
-		printf("@ the End of visionThread_xz().\n");
-		return NULL;
-}
-
-
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-// Camera   ------------------> callback.c
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-void stopVision(void)
-{
-	killVisionThread = 1;
-}
-
-GdkPixbuf *convertOpenCv2Gtk(IplImage *image) //Currently only RGB images with 8 bits per sample are supported. From http://subinsebastien.tumblr.com/post/2839808825/opencv-gtk-and-a-day
-{
-	IplImage *gtkMask;
-//    gtkMask = cvLoadImage("testimage.jpg",CV_LOAD_IMAGE_UNCHANGED);
-
-	gtkMask = image;
-
-	cvCvtColor( image, gtkMask, CV_BGR2RGB );
-    	GdkPixbuf *pix;
-	gdk_threads_enter(); //may not need this here???
-    	pix = gdk_pixbuf_new_from_data((guchar*)gtkMask->imageData,
-              GDK_COLORSPACE_RGB,
-              FALSE,
-              gtkMask->depth,
-              gtkMask->width,
-              gtkMask->height,
-              (gtkMask->widthStep),
-              NULL,
-              NULL);
-	gdk_threads_leave();
-    	return pix;
-}
-
-void set_edgemap(int d)
-{
-	edgemap = d;
-}
-void set_binary(int d)
-{
-	binary = d;
-}
-void setGain_vision(int d)
-{
-	cam.setGain(d);
-}
-void setShutter_vision(int d)
-{
-	cam.setShutter(d);
-}
-void setDilate_vision(int d)
-{
-	dilater = d; //for image processing on edgemap
-}
-void set_binaryThreshold_vision (int d)
-{
-	binaryThreshold = d; //for image processing
-}
-void setvisionParam2_vision(int d)
-{
-	visionParam2 = d; //for image processing
-}
-void set_3d_indicator_flag (int d)
-{
-	flag3dIndicator = d;
-}
-void set_2d_indicator_flag (int d)
-{
-	flag2dIndicator = d;
-}
-void setcannyLow_vision(int d)
-{
-	cannyLow = d; //for image processing
-}
-void setcannyHigh_vision(int d)
-{
-	cannyHigh = d; //for image processing
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-// X-Z Camera   ------------------> callback.c
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-void setTopCam_vision(int d)
-{
-	topcam_on = d; //is the topcam on?
-}
-
-void set_edgemap_xz(int d)
-{
-	edgemap_xz = d;
-}
-void set_binary_xz(int d)
-{
-	binary_xz = d;
-}
-void setGain_xz_vision(int d)
-{
-	cam_xz.setGain_xz(d);
-}
-void setShutter_xz_vision(int d)
-{
-	cam_xz.setShutter_xz(d);
-}
-void setDilate_xz_vision(int d)
-{
-	dilater_xz = d; //for image processing on edgemap
-}
-void set_binaryThreshold_xz_vision(int d)
-{
-	binaryThreshold_xz = d; //for image processing
-}
-void setvisionParam2_xz_vision(int d)
-{
-	visionParam2 = d; //for image processing
-}
-void set_3d_indicator_xz_flag (int d)
-{
-	flag3dIndicatorXZ = d;
-}
-void set_2d_indicator_xz_flag (int d)
-{
-	flag2dIndicatorXZ = d;
-}
-void setcannyLow_xz_vision(int d)
-{
-	cannyLow_xz = d; //for image processing
-}
-void setcannyHigh_xz_vision(int d)
-{
-	cannyHigh_xz = d; //for image processing
-}
-void settopcam_xz_vision(int d)
-{
-	topcam_on = d; //is the sidecam on?
-}
-
-
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-// Set Mouse --- Zhe
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-void setMouse(int whichScreen, int whichMouse, int mouseClick[2] ) //click in pixels
-{
-	switch(whichScreen)
-	{
-		case 0: //top screen
-			switch(whichMouse)
-			{
-				case 1: //left mouse
-					mouse.x 		= mouseClick[0];
-					mouse.y 		= mouseClick[1];
-					break;
-				case 2: //right mouse
-					mouseR.x 		= mouseClick[0];
-					mouseR.y		= mouseClick[1];
-					break;
-				case 3: //center mouse
-					mouseC.x 		= mouseClick[0];
-					mouseC.y 		= mouseClick[1];
-					break;
-			}
-			break;
-		case 1: //side screen
-			switch(whichMouse)
-			{
-				case 1: //left mouse
-					mouse_xz.x 		= mouseClick[0];
-					mouse_xz.y 		= mouseClick[1];
-					break;
-				case 2: //centre mouse
-					mouseC_xz.x 		= mouseClick[0];
-					mouseC_xz.y 		= mouseClick[1];
-					break;
-				case 3: //right mouse
-					mouseR_xz.x 		= mouseClick[0];
-					mouseR_xz.y		= mouseClick[1];
-					break;
-			}
-			break;
-	}
-}
-
-// Chris's function to add digital arena
-static void draw_digital_arena(Mat img, float wall_width, float wall_length, float bound_length, float bound_gap){
-	line(img, Point(0,0), Point(wall_length,0), Scalar(255,0,0), 5); // Top wall
-	line(img, Point(0,wall_width), Point(wall_length,wall_width), Scalar(255,0,0), 5); // Bottom wall
-	line(img, Point(0,0), Point(0,wall_width), Scalar(255,0,0), 5); // Left wall
-	line(img, Point(wall_length,0), Point(wall_length,wall_width), Scalar(255,0,0), 5); // Right wall
-
-	line(img, Point(wall_length/2,0), Point(wall_length/2,bound_length), Scalar(255,0,0), 5);
-	line(img, Point(wall_length/2,bound_length+bound_gap), Point(wall_length/2,2*bound_length+bound_gap), Scalar(255,0,0), 5);
-}
-
-// York's function to detect x,y coordinates
-
-
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-// OpenCV Static Functions   --- Tianqi
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-static void draw_xy_magnetic_field (Mat img, float oX, float oY){
-		float r = 40;
-		float angleXY = atan2(field_y, field_x);
-		float fullMag = 14.0; //when field magnitude equals to this value, the end point of the vector is on the sphere
-
-		//draw figure
-		Point startP(oX,oY);
-		Point endP(oX + r * cos(angleXY), oY - r * sin(angleXY));
-		line( img, startP, endP, Scalar(255,0,0),2);
-		endP.x = oX + r * field_x / fullMag;
-		endP.y = oY - r * field_y / fullMag;
-		circle( img, endP, 2, Scalar(255,0,0),2);
-		circle( img, startP, r, Scalar(255,0,0));
-
-		//put text
-		Point textpoint;
-		textpoint.x = oX - r / 4;
-		textpoint.y = oY + 1.5 * r;
-		char text[] = "XY";
-		putText( img, text, textpoint, FONT_HERSHEY_SIMPLEX, 0.6, Scalar(255, 0, 0));
-}
-
-static void draw_xz_magnetic_field (Mat img, float oX, float oY){
-		float r = 40;
-		float angleXZ = atan2(field_z, field_x);
-		float fullMag = 14.0; //when field magnitude equals to this value, the end point of the vector is on the sphere
-
-		//draw figure
-		Point startP(oX,oY);
-		Point endP(oX + r * cos(angleXZ), oY - r * sin(angleXZ));
-		line( img, startP, endP, Scalar(255,0,0),2);
-		endP.x = oX + r * field_x / fullMag;
-		endP.y = oY - r * field_z / fullMag;
-		circle( img, endP, 2, Scalar(255,0,0),2);
-		circle( img, startP, r, Scalar(255,0,0));
-
-		//put text
-		Point textpoint;
-		textpoint.x = oX - r / 4;
-		textpoint.y = oY + 1.5 * r;
-		char text[] = "XZ";
-		putText( img, text, textpoint, FONT_HERSHEY_SIMPLEX, 0.6, Scalar(255, 0, 0));
-}
-
-static void draw_3d_magnetic_field (Mat img, float oX, float oY){
-		float r = 40;
-		float axisMajor = 2 * r;
-		float axisMinor = 0.5 * r;
-		float angleXY = atan2(field_y, field_x);
-		float mag = field_mag ? field_mag : 14.0;
-		float magXY = sqrt(pow(field_x,2) + pow(field_y,2));
-		float p = magXY / mag;
-		float fullMag = 14.0; //when field magnitude equals to this value, the end point of the vector is on the sphere
-
-		//draw figure
-		Point startP(oX,oY);
-		Point endP;
-		endP.x = oX + (axisMajor * 0.5) * p * cos(angleXY);
-		endP.y = oY - (axisMinor * 0.5) * p * sin(angleXY) - r * field_z / mag;
-		RotatedRect rRect = RotatedRect(Point2f(oX,oY), Size2f(axisMajor,axisMinor), 0);																	// ellipse minimum bounding rect
-		RotatedRect rRectXY = RotatedRect(Point2f(oX,oY - r * field_z / mag), Size2f(axisMajor * p, axisMinor * p), 0);
-		line( img, startP, endP, Scalar(255,0,0), 2);
-		ellipse( img, rRect, Scalar(255,0,0));
-		ellipse( img, rRectXY, Scalar(128,128,0));
-		endP.x = oX + (axisMajor * 0.5) * p * cos(angleXY) * (mag / fullMag);
-		endP.y = oY - (axisMinor * 0.5) * p * sin(angleXY) * (mag / fullMag) - r * field_z / fullMag;
-		circle( img, endP, 2, Scalar(255,0,0), 2);
-		circle( img, startP, r, Scalar(255,0,0));
-
-		//put text
-		Point textpoint;
-		textpoint.x = oX - r / 3;
-		textpoint.y = oY + 1.5 * r;
-		char text[] = "XYZ";
-		putText( img, text, textpoint, FONT_HERSHEY_SIMPLEX, 0.6, Scalar(255, 0, 0));
-}
-
-static void draw_3d_magnetic_field_twisted (Mat img, float oX, float oY){
-		float r = 40;
-		float axisMajor = 2 * r;
-		float axisMinor = 0.5 * r;
-		float angleXY = atan2(field_y, field_x);
-		float mag = field_mag ? field_mag : 14.0;
-		float magXY = sqrt(pow(field_x,2) + pow(field_y,2));
-		float p = magXY / mag;
-		float fullMag = 14.0; //when field magnitude equals to this value, the end point of the vector is on the sphere
-
-		//draw figure
-		Point startP(oX,oY);
-		Point endP;
-		endP.x = oX + (axisMajor * 0.5) * p * cos(angleXY);
-		endP.y = oY - (axisMinor * 0.5) * p * sin(angleXY) - r * field_z / mag;
-		RotatedRect rRect = RotatedRect(Point2f(oX,oY), Size2f(axisMajor,axisMinor), 0);
-		RotatedRect rRectXY = RotatedRect(Point2f(oX+r*cosd(phi/2)*sind(beta),	oY-r*cosd(phi/2)*cosd(beta)),
-																			Size2f(axisMajor*sind(phi/2), axisMinor*sind(phi/2)), beta);
-		// RotatedRect rRectXY = RotatedRect(Point2f(oX+r*cosd(phi/2)*sind(beta)*cosd(theta),
-		// 																					oY-r*cosd(phi/2)*cosd(beta)-(axisMinor * 0.5) * p *sind(theta)),
-		// 																	Size2f(axisMajor*sind(phi/2), axisMinor*sind(phi/2)),
-		// 																	beta*cosd(theta));
-		line( img, startP, endP, Scalar(255,0,0), 2);
-		ellipse( img, rRect, Scalar(255,0,0));
-		ellipse( img, rRectXY, Scalar(128,128,0));
-		endP.x = oX + (axisMajor * 0.5) * p * cos(angleXY) * (mag / fullMag);
-		endP.y = oY - (axisMinor * 0.5) * p * sin(angleXY) * (mag / fullMag) - r * field_z / fullMag;
-		circle( img, endP, 2, Scalar(255,0,0), 2);
-		circle( img, startP, r, Scalar(255,0,0));
-
-		//put text
-		Point textpoint;
-		textpoint.x = oX - r / 3;
-		textpoint.y = oY + 1.5 * r;
-		char text[] = "XYZ";
-		putText( img, text, textpoint, FONT_HERSHEY_SIMPLEX, 0.6, Scalar(0, 255, 0));
-}
-
-static Mat opencv_edgemap (Mat img, int cannyLow, int cannyHigh, int dilater) {
-	Canny(img, img, cannyLow, cannyHigh, 3 ); //edge detect
-	if(dilater > 0) {																										//if dilater = 0, just use original edgemap
-		dilate( img, img, Mat(), Point(-1, -1), dilater, 1, 1);
-		//smooth( img, img, CV_MEDIAN, 5, 5);
-		erode( img, img, Mat(), Point(-1, -1), dilater, 1, 1);
-	}
-	//circle( img, MM, 10, Scalar(20,100,255) , -1, 8, 0 );	          // Test Hough circle detection mode
-	return img;
-}
-
-static Mat opencv_binary (Mat img, int binaryThreshold) {
-	blur( img, img, Size(4,4) ); 												//blur image to remove small blips etc
-	threshold( img, img, binaryThreshold, 255, THRESH_BINARY );
-	return img;
+		while(!killVisionThread) {
+
+        int result=0;
+        result = NETUSBCAM_Init();		// look for ICubes
+    	if(result==0){
+    		printf("No device\n");
+    		return 0; }
+
+      	signal(SIGINT, SignalHandler);		// register signal handler for Ctrl+C
+
+    	result = NETUSBCAM_Open(0);	// open camera
+    	if(result!=0){
+    		printf("Error: Open; Result = %d\n", result);
+    		return 0; }
+
+        // set the camera clock lower, if a lot of bad frames arriving
+    	result = NETUSBCAM_SetCamParameter(0,REG_PLL,20);
+    	if(result!=0){
+    		printf("Error: REG_PLL; Result = %d\n", result);
+    		return 0; }
+
+    	// if active, badframes are sent to the callback with buffersize = 0
+    	result = NETUSBCAM_SetCamParameter(0,REG_CALLBACK_BR_FRAMES,1);
+    	if(result!=0){
+    		printf("Error: REG_CALLBACK_BR_FRAMES; Result = %d\n", result);
+    		return 0; }
+
+        // set the callback to get the frame buffer
+      	result = NETUSBCAM_SetCallback(0,CALLBACK_RGB,&GetImage,NULL);
+      	if(result!=0){
+      		printf("Error: SetCallback; Result = %d\n", result);
+      		return 0; }
+
+      	 // start streaming of camera
+      	result = NETUSBCAM_Start(0);
+      	if(result!=0){
+      		printf("Error: Start; Result = %d\n", result);
+      		return 0; }
+
+
+
+      // VideoCapture cap("test2.mp4");
+      // if(!cap.isOpened()){
+      //   cout << "Error opening video stream or file" << endl;
+      //   return -1;
+      // }
+      int mouse_x_1;
+      int mouse_y_1;
+      int mouse_x_2;
+      int mouse_y_2;
+      int mouse_x_3;
+      int mouse_y_3;
+      int mouse_x_4;
+      int mouse_y_4;
+      int mouse_x_5;
+      int mouse_y_5;
+      int mouse_x_6;
+      int mouse_y_6;
+      int arena_w=400;//abs(mouse_x_1-mouse_x_2);
+      int arena_h=300;//abs(mouse_y_1-mouse_y_2);
+      int occupy[arena_h][arena_w];//the occupy matrix has the size of the arena
+      //Mat frame;
+      Mat hsv;
+      Mat mask;
+      Mat mask2;
+      Mat binaryImg;
+      while(1){
+
+        if(ifframe(camera)){
+
+            vector<vector<Point> > cnts;
+            vector<vector<Point> > cnts2;
+            //cap >> frame;
+            // if (camera.empty())
+            //   break;
+            //frame=frame(Rect(50,40,580,350)); //crop the frame
+
+            //draw arena--------------
+                    line(camera,Point(mouse_x_1,mouse_y_1),Point(mouse_x_1+arena_w,mouse_y_1),Scalar(0,255,0),3);
+                    line(camera,Point(mouse_x_1,mouse_y_1),Point(mouse_x_1,mouse_y_1-arena_h),Scalar(0,255,0),3);
+                    line(camera,Point(mouse_x_2,mouse_y_2),Point(mouse_x_1+arena_w,mouse_y_1),Scalar(0,255,0),3);
+                    line(camera,Point(mouse_x_2,mouse_y_2),Point(mouse_x_1,mouse_y_1-arena_h),Scalar(0,255,0),3);
+                    line(camera,Point(mouse_x_3,mouse_y_3),Point(mouse_x_4,mouse_y_4),Scalar(0,255,0),3);
+                    line(camera,Point(mouse_x_5,mouse_y_5),Point(mouse_x_6,mouse_y_6),Scalar(0,255,0),3);
+            //---------
+
+            cvtColor(camera,hsv,COLOR_BGR2GRAY);
+            inRange(hsv,0,80,mask);
+            Mat maskfororientation = mask;
+            erode(mask,mask,Mat(),Point(-1,-1),2);
+            dilate(mask,mask,Mat(),Point(-1,-1),2);
+        	inRange(hsv,80,230,mask2);
+            erode(mask2,mask2,Mat(),Point(-1,-1),2);
+            dilate(mask2,mask2,Mat(),Point(-1,-1),2);
+            for (int w=0; w<arena_w; w++){
+                occupy[0][w]=3;
+                occupy[arena_h-1][w]=3;
+                for (int j=mouse_y_3; j<mouse_y_4;j++){
+                    occupy[j][w]=3;
+                }
+                for (int j=mouse_y_5; j<mouse_y_6;j++){
+                    occupy[j][w]=3;
+                }
+                for (int h=0; h<arena_h; h++){
+                    occupy[h][0]=3;
+                    occupy[h][arena_w-1]=3;
+                    if (mask.at<int>(h,w)==255){
+                        occupy[h][w]=1;
+                    }
+                    if (mask2.at<int>(h,w)==255){
+                        occupy[h][w]=2;
+                    }
+                }
+            }
+
+
+            findContours(mask,cnts,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE,Point(0,0));
+        	findContours(mask2,cnts2,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE,Point(0,0));
+
+            if ((int)cnts.size()>0 && (int)cnts2.size()>0){
+
+                sort(cnts.begin(), cnts.end(),compareContourAreas);
+
+            	sort(cnts2.begin(), cnts2.end(),compareContourAreas);
+
+                //printf("size: %d\n", (int)cnts.size());
+                vector<RotatedRect> output(cnts.size());
+
+                for( int i = 0; i < cnts.size(); i++ ){
+                    output[i] = minAreaRect(cnts[i]);
+                }
+                float r_x=output[0].center.x;
+                float r_y=output[0].center.y;
+                float r_w=output[0].size.width;
+                float r_h=output[0].size.height;
+
+        		drawContours(camera,cnts,0,Scalar(0,0,255),2);
+                putText(camera,"Robot",Point((int)r_x,(int)r_y),FONT_HERSHEY_SIMPLEX,0.5,255,2);
+                Point2f center;
+                float radius;
+                //for( int i = 0; i < cnts2.size(); i++ ){
+                minEnclosingCircle(cnts2[0],center,radius);
+                //}
+                float c_x=center.x;
+                float c_y=center.y;
+                float c_r=radius;
+                circle(camera, Point((int)c_x,(int)c_y), (int)radius, Scalar(0, 255, 0), 2, 8, 0 );
+                putText(camera,"Cargo",Point((int)c_x,(int)c_y),FONT_HERSHEY_SIMPLEX,0.5,255,2);
+
+
+                //get robot angle___________________________________________________________________________
+                threshold (camera, binaryImg, 65, 255, THRESH_BINARY_INV );
+                float tempAngle = output[0].angle;          // get angle of rotated rect
+                int checkPt[8];
+                //printf("angle: %.3f, width: %.3f, height: %.3f\n", tempAngle, width, height);
+                checkPt[0] = r_x - 0.4 * r_w  * cosd(tempAngle);
+                checkPt[1] = r_y - 0.4 * r_h * sind(tempAngle);
+                checkPt[2] = r_x + 0.4 * r_h * sind(tempAngle);
+                checkPt[3] = r_y - 0.4 * r_h * cosd(tempAngle);
+                checkPt[4] = r_x + 0.4 * r_w  * cosd(tempAngle);
+                checkPt[5] = r_y + 0.4 * r_h * sind(tempAngle);
+                checkPt[6] = r_x - 0.4 * r_w  * sind(tempAngle);
+                checkPt[7] = r_y + 0.4 * r_h * cosd(tempAngle);
+
+                float r_angle;
+                int iDir = -1;
+                if (maskfororientation.at<unsigned char>(checkPt[1],checkPt[0]) == 0){
+                    iDir = 0;
+                    r_angle=output[0].angle+180;}
+                else if (maskfororientation.at<unsigned char>(checkPt[3],checkPt[2]) == 0){
+                    iDir = 1;
+                    r_angle=output[0].angle+270;}
+                else if (maskfororientation.at<unsigned char>(checkPt[5],checkPt[4]) == 0){
+                    iDir = 2;
+                    r_angle=output[0].angle+360;}
+                else if (maskfororientation.at<unsigned char>(checkPt[7],checkPt[6]) == 0){
+                    iDir = 3;
+                    r_angle=output[0].angle+90;}
+                circle(camera, Point(checkPt[iDir*2], checkPt[iDir*2+1]), 5, Scalar(255,0,0));
+                printf("Robot Angle: %.2f\n",r_angle);
+                //___________________________________________________________________________________
+                // printf("Angle: %.2f\n",r_angle);
+                // printf("X Position: %.2f\n",r_x);
+                // printf("Y Position: %.2f\n",r_y);
+
+            }
+
+
+            imshow("camera",camera);
+
+            char c=(char)waitKey(1);
+            if(c==27) break;
+          }
+      }
+
+      //pause();
+      // cap.release();
+      // destroyAllWindows();
+
+      // stop streaming of camera
+      result = NETUSBCAM_Stop(0);
+      if(result!=0){
+          printf("Error: Stop; Result = %d\n", result);
+          return 0; }
+
+      // close camera
+      result = NETUSBCAM_Close(0);
+      if(result!=0){
+          printf("Error: Close; Result = %d\n", result);
+          return 0; }
+
+      return 0;
+  }
 }
diff --git a/York/test-circle b/York/test-circle
index d209f46..527f28b 100755
Binary files a/York/test-circle and b/York/test-circle differ
diff --git a/York/test-circle.cpp b/York/test-circle.cpp
index cc9f711..22b9b2f 100644
--- a/York/test-circle.cpp
+++ b/York/test-circle.cpp
@@ -2,192 +2,249 @@
 #include <iostream>
 #include <stdio.h>
 #include <vector>
-#include <iostream>
 #include <string.h>
 #include "general_header.hpp"
 #include "NETUSBCAM_API.h"
 #include "ICubeDefines.h"
+#include <unistd.h>
+#include <signal.h>
+
+#include "opencv2/objdetect.hpp"
+#include "opencv2/highgui.hpp"
+#include "opencv2/imgproc.hpp"
+
 //Read: usable variables: Robot: r_x,r_y,r_angle; Cargo: c_x,c_y
 
 //~/Desktop/Undergraduate_Thesis/York$ g++ `pkg-config --cflags gtk+-3.0` `pkg-config --cflags opencv` -o test test.cpp `pkg-config --libs opencv` `pkg-config --libs gtk+-3.0` -lNETUSBCAM
+//g++ -o test test.cpp `pkg-config --libs gtk+-3.0` `pkg-config --cflags --libs opencv --libs` -lNETUSBCAM
 //~/Desktop/Undergraduate_Thesis/York$ ./test
 
 using namespace std;
 using namespace cv;
+Mat camera;
 
-bool compareContourAreas ( vector<Point> contour1, vector<Point> contour2 ) {
+// ========================================================================
+// Internal Functions
+// ========================================================================
+bool compareContourAreas(vector<Point> contour1, vector<Point> contour2){
     double i = fabs( contourArea(Mat(contour1)) );
     double j = fabs( contourArea(Mat(contour2)) );
-    return ( i < j );
+    return (i < j);
 }
 
-// unsigned int nGoodCnt=0;
-// unsigned int nBadCnt=0;
-// int GetImage(void *buffer, unsigned int buffersize, void *context)
-// {
-//   if(buffersize==0){		// badframe arrived (this happens here, when (REG_CALLBACK_BR_FRAMES==1)
-// 	nBadCnt++;
-//   }
-//   else				// good frame arrived
-//   {
-// 	nGoodCnt++;
-//   char filename[24];
-//   sprintf(filename,"Output%d.jpg",nGoodCnt);
-//   printf("%p",buffer);
-//
-// 	#ifdef SAVE_RAW
-//   printf("%p\n", buffer);
-// 	char buf[24];
-// 	sprintf(buf,"Nr%d.raw",nGoodCnt);
-// 	SaveRaw((unsigned char*)buffer,buffersize,buf);
-// 	#endif
-//   }
-// }
-
-int main(){
+void SignalHandler(int i){
+   signal(SIGINT, SignalHandler);
+}
 
-  // Create a VideoCapture object and open the input file
-  // If the input is the web camera, pass 0 instead of the video file name
-
-  // NETUSBCAM_Init();
-  // NETUSBCAM_Open(0);
-  // NETUSBCAM_SetCamParameter(0,REG_PLL,20);
-  // NETUSBCAM_SetCamParameter(0,REG_CALLBACK_BR_FRAMES,1);
-  // NETUSBCAM_SetCallback(0,CALLBACK_RGB,&GetImage,NULL);
-  // NETUSBCAM_Start(0);
-  VideoCapture cap("test2.mp4");
-  if(!cap.isOpened()){
-    cout << "Error opening video stream or file" << endl;
-    return -1;
-  }
-  int mouse_x_1;
-  int mouse_y_1;
-  int mouse_x_2;
-  int mouse_y_2;
-  int arena_w=400;//abs(mouse_x_1-mouse_x_2);
-  int arena_h=300;//abs(mouse_y_1-mouse_y_2);
-  int occupy[arena_h][arena_w];//the occupy matrix has the size of the arena
-  Mat frame;
-  Mat hsv;
-  Mat mask;
-  Mat mask2;
-  Mat binaryImg;
-  while(1){
-    vector<vector<Point> > cnts;
-    vector<vector<Point> > cnts2;
-    cap >> frame;
-    if (frame.empty())
-      break;
-    frame=frame(Rect(50,40,580,350)); //crop the frame
-    cvtColor(frame,hsv,COLOR_BGR2GRAY);
-    inRange(hsv,0,60,mask);
-    Mat maskfororientation = mask;
-    erode(mask,mask,Mat(),Point(-1,-1),2);
-    dilate(mask,mask,Mat(),Point(-1,-1),2);
-    imshow("hsv", mask);
-	inRange(hsv,80,230,mask2);
-    erode(mask2,mask2,Mat(),Point(-1,-1),2);
-    dilate(mask2,mask2,Mat(),Point(-1,-1),2);
-    for (int w=0; w<arena_w; w++){
-        for (int h=0; h<arena_h; h++){
-            if (mask.at<int>(h,w)==255){
-                occupy[h][w]=1;
-            }
-            if (mask2.at<int>(h,w)==255){
-                occupy[h][w]=2;
-            }
-        }
+int GetImage(void *buffer, unsigned int buffersize, void *context){
+    if(buffersize > 0){ // [Tianqi] <= 0 indicates a bad frame is coming. e.g. the first few frames after initializing the camera
+        camera = Mat(1024,1280, CV_8UC3, buffer);
     }
+}
 
+int isFrameValid(Mat camera){
+    Size s = camera.size();
+    int rows = s.height;
+    int cols = s.width;
+    if (rows > 0 && cols > 0){
+        return 1;
+    } else{
+        return 0;
+    }
+}
 
-    findContours(mask,cnts,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE,Point(0,0));
-	findContours(mask2,cnts2,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE,Point(0,0));
-
-    if ((int)cnts.size()>0){
-
-        sort(cnts.begin(), cnts.end(),compareContourAreas);
-
-    	sort(cnts2.begin(), cnts2.end(),compareContourAreas);
-
-        //printf("size: %d\n", (int)cnts.size());
-        vector<RotatedRect> output(cnts.size());
-
-        for( int i = 0; i < cnts.size(); i++ ){
-            output[i] = minAreaRect(cnts[i]);
-        }
-        float r_x=output[0].center.x;
-        float r_y=output[0].center.y;
-        float r_w=output[0].size.width;
-        float r_h=output[0].size.height;
-
-		drawContours(frame,cnts,0,Scalar(0,0,255),2);
-        putText(frame,"Robot",Point((int)r_x,(int)r_y),FONT_HERSHEY_SIMPLEX,0.5,255,2);
-        Point2f center;
-        float radius;
-        //for( int i = 0; i < cnts2.size(); i++ ){
-        minEnclosingCircle(cnts2[0],center,radius);
-        //}
-        float c_x=center.x;
-        float c_y=center.y;
-        float c_r=radius;
-        circle(frame, Point((int)c_x,(int)c_y), (int)radius, Scalar(0, 255, 0), 2, 8, 0 );
-        putText(frame,"Cargo",Point((int)c_x,(int)c_y),FONT_HERSHEY_SIMPLEX,0.5,255,2);
-
-
-        //get robot angle___________________________________________________________________________
-        threshold (frame, binaryImg, 65, 255, THRESH_BINARY_INV );
-        float tempAngle = output[0].angle;          // get angle of rotated rect
-        int checkPt[8];
-        //printf("angle: %.3f, width: %.3f, height: %.3f\n", tempAngle, width, height);
-        checkPt[0] = r_x - 0.4 * r_w  * cosd(tempAngle);
-        checkPt[1] = r_y - 0.4 * r_h * sind(tempAngle);
-        checkPt[2] = r_x + 0.4 * r_h * sind(tempAngle);
-        checkPt[3] = r_y - 0.4 * r_h * cosd(tempAngle);
-        checkPt[4] = r_x + 0.4 * r_w  * cosd(tempAngle);
-        checkPt[5] = r_y + 0.4 * r_h * sind(tempAngle);
-        checkPt[6] = r_x - 0.4 * r_w  * sind(tempAngle);
-        checkPt[7] = r_y + 0.4 * r_h * cosd(tempAngle);
-        //printf("binary image channel %d depth %d\n", binaryImg.channels(), binaryImg.depth());
-        //printf("pt1 %d pt2 %d pt3 %d pt4 %d\n", binaryImg.at<unsigned char>(checkPt[1],checkPt[0]),
-        //                                        binaryImg.at<unsigned char>(checkPt[3],checkPt[2]),
-        //                                        binaryImg.at<unsigned char>(checkPt[5],checkPt[4]),
-        //                                        binaryImg.at<unsigned char>(checkPt[7],checkPt[6]));
-
-        float r_angle;
-        int iDir = -1;
-        if (maskfororientation.at<unsigned char>(checkPt[1],checkPt[0]) == 0){
-            iDir = 0;
-            r_angle=output[0].angle+180;}
-        else if (maskfororientation.at<unsigned char>(checkPt[3],checkPt[2]) == 0){
-            iDir = 1;
-            r_angle=output[0].angle+270;}
-        else if (maskfororientation.at<unsigned char>(checkPt[5],checkPt[4]) == 0){
-            iDir = 2;
-            r_angle=output[0].angle+360;}
-        else if (maskfororientation.at<unsigned char>(checkPt[7],checkPt[6]) == 0){
-            iDir = 3;
-            r_angle=output[0].angle+90;}
-        circle(frame, Point(checkPt[iDir*2], checkPt[iDir*2+1]), 5, Scalar(255,0,0));
-        printf("Robot Angle: %.2f\n",r_angle);
-        //___________________________________________________________________________________
-        // printf("Angle: %.2f\n",r_angle);
-        // printf("X Position: %.2f\n",r_x);
-        // printf("Y Position: %.2f\n",r_y);
-
+int initCamera(int CAM_ID){
+    int result;
+    result = NETUSBCAM_Init();		// look for ICubes
+	if(result==0){
+		printf("No device\n");
+		return 0;
     }
-    else {
-        break;
+	result = NETUSBCAM_Open(CAM_ID);	// open camera
+	if(result!=0){
+		printf("Error: Open; Result = %d\n", result);
+		return 0;
     }
+    // set the camera clock lower, if a lot of bad frames arriving
+	result = NETUSBCAM_SetCamParameter(CAM_ID,REG_PLL,20);
+	if(result!=0){
+		printf("Error: REG_PLL; Result = %d\n", result);
+		return 0;
+    }
+	// if active, badframes are sent to the callback with buffersize = 0
+	result = NETUSBCAM_SetCamParameter(CAM_ID,REG_CALLBACK_BR_FRAMES,1);
+	if(result!=0){
+		printf("Error: REG_CALLBACK_BR_FRAMES; Result = %d\n", result);
+		return 0;
+    }
+    // set the callback to get the frame buffer
+  	result = NETUSBCAM_SetCallback(CAM_ID,CALLBACK_RGB,&GetImage,NULL);
+  	if(result!=0){
+  		printf("Error: SetCallback; Result = %d\n", result);
+  		return 0;
+    }
+  	 // start streaming of camera
+  	result = NETUSBCAM_Start(CAM_ID);
+  	if(result!=0){
+  		printf("Error: Start; Result = %d\n", result);
+  		return 0;
+    }
+    return 1;
+}
 
-    imshow( "Frame", frame);
-
-    char c=(char)waitKey(25);
-    if(c==27)
-      break;
-  }
-  //NETUSBCAM_Stop(0);
-  cap.release();
-  destroyAllWindows();
+int closeCamera(int CAM_ID){
+    int result;
+    // stop streaming of camera
+    result = NETUSBCAM_Stop(CAM_ID);
+    if(result!=0){
+      printf("Error: Stop; Result = %d\n", result);
+      return 0;
+    }
+    // close camera
+    result = NETUSBCAM_Close(CAM_ID);
+    if(result!=0){
+      printf("Error: Close; Result = %d\n", result);
+      return 0;
+    }
+    return 1;
+}
+// ========================================================================
+// Main
+// ========================================================================
+int main(){
+  	signal(SIGINT, SignalHandler);		// register signal handler for Ctrl+C
+    if(!initCamera(0)) return 0;
+
+    int mouse_x_1;
+    int mouse_y_1;
+    int mouse_x_2;
+    int mouse_y_2;
+    int mouse_x_3;
+    int mouse_y_3;
+    int mouse_x_4;
+    int mouse_y_4;
+    int mouse_x_5;
+    int mouse_y_5;
+    int mouse_x_6;
+    int mouse_y_6;
+    int arena_w = 400;              //abs(mouse_x_1-mouse_x_2);
+    int arena_h = 300;              //abs(mouse_y_1-mouse_y_2);
+    int occupy[arena_h][arena_w];   //the occupy matrix has the size of the arena
+
+    while(1){
+        if(!isFrameValid(camera)) continue; // continue if receiving an empty frame
+        Mat hsv;
+        Mat mask;
+        Mat mask2;
+        Mat binaryImg;
+        vector<vector<Point> > cnts;
+        vector<vector<Point> > cnts2;
+
+        // draw arena
+        line(camera,Point(mouse_x_1,mouse_y_1),Point(mouse_x_1+arena_w,mouse_y_1),Scalar(0,255,0),3);
+        line(camera,Point(mouse_x_1,mouse_y_1),Point(mouse_x_1,mouse_y_1-arena_h),Scalar(0,255,0),3);
+        line(camera,Point(mouse_x_2,mouse_y_2),Point(mouse_x_1+arena_w,mouse_y_1),Scalar(0,255,0),3);
+        line(camera,Point(mouse_x_2,mouse_y_2),Point(mouse_x_1,mouse_y_1-arena_h),Scalar(0,255,0),3);
+        line(camera,Point(mouse_x_3,mouse_y_3),Point(mouse_x_4,mouse_y_4),Scalar(0,255,0),3);
+        line(camera,Point(mouse_x_5,mouse_y_5),Point(mouse_x_6,mouse_y_6),Scalar(0,255,0),3);
+
+
+        cvtColor(camera,hsv,COLOR_BGR2GRAY);
+
+        inRange(hsv,0,80,mask);
+        Mat maskfororientation = mask;
+        erode(mask,mask,Mat(),Point(-1,-1),2);
+        dilate(mask,mask,Mat(),Point(-1,-1),2);
+
+    	inRange(hsv,80,230,mask2);
+        erode(mask2,mask2,Mat(),Point(-1,-1),2);
+        dilate(mask2,mask2,Mat(),Point(-1,-1),2);
+
+        // [Tianqi] It gives me a lot of segmentation faults to the following lines.
+
+        // for (int w=0; w<arena_w; w++){
+        //     occupy[0][w]=3;
+        //     occupy[arena_h-1][w]=3;
+        //     for (int j=mouse_y_3; j<mouse_y_4;j++) {occupy[j][w]=3;}
+        //     for (int j=mouse_y_5; j<mouse_y_6;j++) {occupy[j][w]=3;}
+        //     for (int h=0; h<arena_h; h++){
+        //         occupy[h][0]=3;
+        //         occupy[h][arena_w-1]=3;
+        //         if (mask.at<int>(h,w)==255) {occupy[h][w]=1;}
+        //         if (mask2.at<int>(h,w)==255) {occupy[h][w]=2;}
+        //     }
+        // }
+
+        findContours(mask,cnts,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE,Point(0,0));
+    	findContours(mask2,cnts2,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE,Point(0,0));
+
+        if ((int)cnts.size()>0 && (int)cnts2.size()>0){
+            sort(cnts.begin(), cnts.end(),compareContourAreas);
+            sort(cnts2.begin(), cnts2.end(),compareContourAreas);
+
+            //printf("size: %d\n", (int)cnts.size());
+            vector<RotatedRect> output(cnts.size());
+
+            for( int i = 0; i < cnts.size(); i++ ){
+                output[i] = minAreaRect(cnts[i]);
+            }
+            float r_x=output[0].center.x;
+            float r_y=output[0].center.y;
+            float r_w=output[0].size.width;
+            float r_h=output[0].size.height;
+
+    		drawContours(camera,cnts,0,Scalar(0,0,255),2);
+            putText(camera,"Robot",Point((int)r_x,(int)r_y),FONT_HERSHEY_SIMPLEX,0.5,255,2);
+            Point2f center;
+            float radius;
+
+            minEnclosingCircle(cnts2[0],center,radius);
+
+            float c_x=center.x;
+            float c_y=center.y;
+            float c_r=radius;
+            circle(camera, Point((int)c_x,(int)c_y), (int)radius, Scalar(0, 255, 0), 2, 8, 0 );
+            putText(camera,"Cargo",Point((int)c_x,(int)c_y),FONT_HERSHEY_SIMPLEX,0.5,255,2);
+
+            //get robot angle___________________________________________________________________________
+            threshold (camera, binaryImg, 65, 255, THRESH_BINARY_INV );
+            float tempAngle = output[0].angle;          // get angle of rotated rect
+            int checkPt[8];
+            //printf("angle: %.3f, width: %.3f, height: %.3f\n", tempAngle, width, height);
+            checkPt[0] = r_x - 0.4 * r_w  * cosd(tempAngle);
+            checkPt[1] = r_y - 0.4 * r_h * sind(tempAngle);
+            checkPt[2] = r_x + 0.4 * r_h * sind(tempAngle);
+            checkPt[3] = r_y - 0.4 * r_h * cosd(tempAngle);
+            checkPt[4] = r_x + 0.4 * r_w  * cosd(tempAngle);
+            checkPt[5] = r_y + 0.4 * r_h * sind(tempAngle);
+            checkPt[6] = r_x - 0.4 * r_w  * sind(tempAngle);
+            checkPt[7] = r_y + 0.4 * r_h * cosd(tempAngle);
+
+            float r_angle;
+            int iDir = -1;
+            if (maskfororientation.at<unsigned char>(checkPt[1],checkPt[0]) == 0){
+                iDir = 0;
+                r_angle=output[0].angle+180;}
+            else if (maskfororientation.at<unsigned char>(checkPt[3],checkPt[2]) == 0){
+                iDir = 1;
+                r_angle=output[0].angle+270;}
+            else if (maskfororientation.at<unsigned char>(checkPt[5],checkPt[4]) == 0){
+                iDir = 2;
+                r_angle=output[0].angle+360;}
+            else if (maskfororientation.at<unsigned char>(checkPt[7],checkPt[6]) == 0){
+                iDir = 3;
+                r_angle=output[0].angle+90;}
+            circle(camera, Point(checkPt[iDir*2], checkPt[iDir*2+1]), 5, Scalar(255,0,0));
+            printf("Robot Angle: %.2f\n",r_angle);
+            printf("Angle: %.2f\n",r_angle);
+            printf("X Position: %.2f\n",r_x);
+            printf("Y Position: %.2f\n",r_y);
+        }
 
-  return 0;
+        imshow("camera",camera);
+        char c = (char)waitKey(15); // duration of the frames (ms)
+        if (c == 27) break; // exit when pressing ESC key
+    }
+    closeCamera(0);
+    return 0;
 }
diff --git a/York/test-rectangle b/York/test-rectangle
index 0880401..5e1beb5 100755
Binary files a/York/test-rectangle and b/York/test-rectangle differ
diff --git a/York/test-rectangle.cpp b/York/test-rectangle.cpp
index 4619cc3..74c4cdf 100644
--- a/York/test-rectangle.cpp
+++ b/York/test-rectangle.cpp
@@ -2,12 +2,18 @@
 #include <iostream>
 #include <stdio.h>
 #include <vector>
-#include <iostream>
 #include <string.h>
 #include "general_header.hpp"
 #include "NETUSBCAM_API.h"
 #include "ICubeDefines.h"
-//Read: usable variables: Robot: r_x,r_y,r_angle; Cargo: c_x,c_y,c_angle
+#include <unistd.h>
+#include <signal.h>
+
+#include "opencv2/objdetect.hpp"
+#include "opencv2/highgui.hpp"
+#include "opencv2/imgproc.hpp"
+
+//Read: usable variables: Robot: r_x,r_y,r_angle; Cargo: c_x,c_y
 
 //~/Desktop/Undergraduate_Thesis/York$ g++ `pkg-config --cflags gtk+-3.0` `pkg-config --cflags opencv` -o test test.cpp `pkg-config --libs opencv` `pkg-config --libs gtk+-3.0` -lNETUSBCAM
 //~/Desktop/Undergraduate_Thesis/York$ ./test
@@ -21,184 +27,250 @@ bool compareContourAreas ( vector<Point> contour1, vector<Point> contour2 ) {
     return ( i < j );
 }
 
-// unsigned int nGoodCnt=0;
-// unsigned int nBadCnt=0;
-// int GetImage(void *buffer, unsigned int buffersize, void *context)
-// {
-//   if(buffersize==0){		// badframe arrived (this happens here, when (REG_CALLBACK_BR_FRAMES==1)
-// 	nBadCnt++;
-//   }
-//   else				// good frame arrived
-//   {
-// 	nGoodCnt++;
-//   char filename[24];
-//   sprintf(filename,"Output%d.jpg",nGoodCnt);
-//   printf("%p",buffer);
-//
-// 	#ifdef SAVE_RAW
-//   printf("%p\n", buffer);
-// 	char buf[24];
-// 	sprintf(buf,"Nr%d.raw",nGoodCnt);
-// 	SaveRaw((unsigned char*)buffer,buffersize,buf);
-// 	#endif
-//   }
-// }
+void SignalHandler(int i)
+{
+   signal(SIGINT, SignalHandler);
+}
+
+Mat camera;
+int GetImage(void *buffer, unsigned int buffersize, void *context)
+{
+  camera = Mat(1024,1280, CV_8UC3, buffer);
+}
+
+int ifframe(Mat camera){
+    Size s = camera.size();
+    int rows = s.height;
+    int cols = s.width;
+    if (rows > 0 && cols > 0){
+        return 1;
+    } else{
+        return 0;
+    }
+}
 
 int main(){
+printf("hi1");
+    int result=0;
+    result = NETUSBCAM_Init();		// look for ICubes
+	if(result==0){
+		printf("No device\n");
+		return 0; }
+printf("hi2");
+  	signal(SIGINT, SignalHandler);		// register signal handler for Ctrl+C
 
-  // Create a VideoCapture object and open the input file
-  // If the input is the web camera, pass 0 instead of the video file name
-
-  // NETUSBCAM_Init();
-  // NETUSBCAM_Open(0);
-  // NETUSBCAM_SetCamParameter(0,REG_PLL,20);
-  // NETUSBCAM_SetCamParameter(0,REG_CALLBACK_BR_FRAMES,1);
-  // NETUSBCAM_SetCallback(0,CALLBACK_RGB,&GetImage,NULL);
-  // NETUSBCAM_Start(0);
-  VideoCapture cap("test2.mp4");
-  if(!cap.isOpened()){
-    cout << "Error opening video stream or file" << endl;
-    return -1;
-  }
+	result = NETUSBCAM_Open(0);	// open camera
+	if(result!=0){
+		printf("Error: Open; Result = %d\n", result);
+		return 0; }
+
+    // set the camera clock lower, if a lot of bad frames arriving
+	result = NETUSBCAM_SetCamParameter(0,REG_PLL,20);
+	if(result!=0){
+		printf("Error: REG_PLL; Result = %d\n", result);
+		return 0; }
+
+	// if active, badframes are sent to the callback with buffersize = 0
+	result = NETUSBCAM_SetCamParameter(0,REG_CALLBACK_BR_FRAMES,1);
+	if(result!=0){
+		printf("Error: REG_CALLBACK_BR_FRAMES; Result = %d\n", result);
+		return 0; }
+
+    // set the callback to get the frame buffer
+  	result = NETUSBCAM_SetCallback(0,CALLBACK_RGB,&GetImage,NULL);
+  	if(result!=0){
+  		printf("Error: SetCallback; Result = %d\n", result);
+  		return 0; }
+
+  	 // start streaming of camera
+  	result = NETUSBCAM_Start(0);
+  	if(result!=0){
+  		printf("Error: Start; Result = %d\n", result);
+  		return 0; }
+
+
+  // VideoCapture cap("test2.mp4");
+  // if(!cap.isOpened()){
+  //   cout << "Error opening video stream or file" << endl;
+  //   return -1;
+  // }
   int mouse_x_1;
   int mouse_y_1;
   int mouse_x_2;
   int mouse_y_2;
+  int mouse_x_3;
+  int mouse_y_3;
+  int mouse_x_4;
+  int mouse_y_4;
+  int mouse_x_5;
+  int mouse_y_5;
+  int mouse_x_6;
+  int mouse_y_6;
   int arena_w=400;//abs(mouse_x_1-mouse_x_2);
   int arena_h=300;//abs(mouse_y_1-mouse_y_2);
   int occupy[arena_h][arena_w];//the occupy matrix has the size of the arena
-  Mat frame;
+  //Mat frame;
   Mat hsv;
   Mat mask;
   Mat mask2;
   Mat binaryImg;
-  vector<vector<Point> > cnts;
-  vector<vector<Point> > cnts2;
   while(1){
-    cap >> frame;
-    if (frame.empty())
-      break;
-    frame=frame(Rect(50,40,580,350)); //crop the frame
-    cvtColor(frame,hsv,COLOR_BGR2GRAY);
-    inRange(hsv,0,60,mask);
-    Mat maskfororientation = mask;
-    erode(mask,mask,Mat(),Point(-1,-1),2);
-    dilate(mask,mask,Mat(),Point(-1,-1),2);
-    imshow("hsv", mask);
-	inRange(hsv,80,230,mask2);
-    erode(mask2,mask2,Mat(),Point(-1,-1),2);
-    dilate(mask2,mask2,Mat(),Point(-1,-1),2);
-    for (int w=0; w<arena_w; w++){
-        for (int h=0; h<arena_h; h++){
-            if (mask.at<int>(h,w)==255){
-                occupy[h][w]=1;
+
+    if(ifframe(camera)){
+
+        vector<vector<Point> > cnts;
+        vector<vector<Point> > cnts2;
+        //cap >> frame;
+        // if (camera.empty())
+        //   break;
+        //frame=frame(Rect(50,40,580,350)); //crop the frame
+
+        //draw arena--------------
+                line(camera,Point(mouse_x_1,mouse_y_1),Point(mouse_x_1+arena_w,mouse_y_1),Scalar(0,255,0),3);
+                line(camera,Point(mouse_x_1,mouse_y_1),Point(mouse_x_1,mouse_y_1-arena_h),Scalar(0,255,0),3);
+                line(camera,Point(mouse_x_2,mouse_y_2),Point(mouse_x_1+arena_w,mouse_y_1),Scalar(0,255,0),3);
+                line(camera,Point(mouse_x_2,mouse_y_2),Point(mouse_x_1,mouse_y_1-arena_h),Scalar(0,255,0),3);
+                line(camera,Point(mouse_x_3,mouse_y_3),Point(mouse_x_4,mouse_y_4),Scalar(0,255,0),3);
+                line(camera,Point(mouse_x_5,mouse_y_5),Point(mouse_x_6,mouse_y_6),Scalar(0,255,0),3);
+        //---------
+
+        cvtColor(camera,hsv,COLOR_BGR2GRAY);
+        inRange(hsv,0,80,mask);
+        Mat maskfororientation = mask;
+        erode(mask,mask,Mat(),Point(-1,-1),2);
+        dilate(mask,mask,Mat(),Point(-1,-1),2);
+    	inRange(hsv,80,230,mask2);
+        erode(mask2,mask2,Mat(),Point(-1,-1),2);
+        dilate(mask2,mask2,Mat(),Point(-1,-1),2);
+        for (int w=0; w<arena_w; w++){
+            occupy[0][w]=3;
+            occupy[arena_h-1][w]=3;
+            for (int j=mouse_y_3; j<mouse_y_4;j++){
+                occupy[j][w]=3;
+            }
+            for (int j=mouse_y_5; j<mouse_y_6;j++){
+                occupy[j][w]=3;
             }
-            if (mask2.at<int>(h,w)==255){
-                occupy[h][w]=2;
+            for (int h=0; h<arena_h; h++){
+                occupy[h][0]=3;
+                occupy[h][arena_w-1]=3;
+                if (mask.at<int>(h,w)==255){
+                    occupy[h][w]=1;
+                }
+                if (mask2.at<int>(h,w)==255){
+                    occupy[h][w]=2;
+                }
             }
         }
-    }
 
-    findContours(mask,cnts,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE,Point(0,0));
-	findContours(mask2,cnts2,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE,Point(0,0));
+        findContours(mask,cnts,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE,Point(0,0));
+        findContours(mask2,cnts2,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE,Point(0,0));
 
-    if ((int)cnts.size()>0){
+        if ((int)cnts.size()>0){
 
-        sort(cnts.begin(), cnts.end(),compareContourAreas);
+            sort(cnts.begin(), cnts.end(),compareContourAreas);
 
-    	sort(cnts2.begin(), cnts2.end(),compareContourAreas);
+            sort(cnts2.begin(), cnts2.end(),compareContourAreas);
 
-        //printf("size: %d\n", (int)cnts.size());
-        vector<RotatedRect> output(cnts.size());
-        vector<RotatedRect> output2(cnts2.size());
+            //printf("size: %d\n", (int)cnts.size());
+            vector<RotatedRect> output(cnts.size());
+            vector<RotatedRect> output2(cnts2.size());
 
-        for( int i = 0; i < cnts.size(); i++ ){
-            output[i] = minAreaRect(cnts[i]);
-        }
-        float r_x=output[0].center.x;
-        float r_y=output[0].center.y;
-        float r_w=output[0].size.width;
-        float r_h=output[0].size.height;
+            for( int i = 0; i < cnts.size(); i++ ){
+                output[i] = minAreaRect(cnts[i]);
+            }
+            float r_x=output[0].center.x;
+            float r_y=output[0].center.y;
+            float r_w=output[0].size.width;
+            float r_h=output[0].size.height;
 
-		drawContours(frame,cnts,0,Scalar(0,0,255),2);
-        putText(frame,"Robot",Point((int)r_x,(int)r_y),FONT_HERSHEY_SIMPLEX,0.5,255,2);
+            drawContours(camera,cnts,0,Scalar(0,0,255),2);
+            putText(camera,"Robot",Point((int)r_x,(int)r_y),FONT_HERSHEY_SIMPLEX,0.5,255,2);
 
-        //for( int i = 0; i < cnts2.size(); i++ ){
+            //for( int i = 0; i < cnts2.size(); i++ ){
+
+            for( int i = 0; i < cnts2.size(); i++ ){
+                output2[i] = minAreaRect(cnts2[i]);
+            }
+            float c_x=output2[0].center.x;
+            float c_y=output2[0].center.y;
+            float c_w=output2[0].size.width;
+            float c_h=output2[0].size.height;
+            float c_angle=output2[0].angle;
+            if (c_w<c_h){
+                c_angle=90-c_angle;
+            }
+            else {
+                c_angle=0-c_angle;
+            }
+            printf("Cargo Angle: %.2f\n",c_angle);
+            drawContours(camera,cnts2,0,Scalar(0,255,0),2);
+
+            putText(camera,"Cargo",Point((int)c_x,(int)c_y),FONT_HERSHEY_SIMPLEX,0.5,255,2);
+
+
+            //get robot angle___________________________________________________________________________
+            threshold (camera, binaryImg, 65, 255, THRESH_BINARY_INV );
+            float tempAngle = output[0].angle;          // get angle of rotated rect
+            int checkPt[8];
+            //printf("angle: %.3f, width: %.3f, height: %.3f\n", tempAngle, width, height);
+            checkPt[0] = r_x - 0.4 * r_w  * cosd(tempAngle);
+            checkPt[1] = r_y - 0.4 * r_h * sind(tempAngle);
+            checkPt[2] = r_x + 0.4 * r_h * sind(tempAngle);
+            checkPt[3] = r_y - 0.4 * r_h * cosd(tempAngle);
+            checkPt[4] = r_x + 0.4 * r_w  * cosd(tempAngle);
+            checkPt[5] = r_y + 0.4 * r_h * sind(tempAngle);
+            checkPt[6] = r_x - 0.4 * r_w  * sind(tempAngle);
+            checkPt[7] = r_y + 0.4 * r_h * cosd(tempAngle);
+            //printf("binary image channel %d depth %d\n", binaryImg.channels(), binaryImg.depth());
+            //printf("pt1 %d pt2 %d pt3 %d pt4 %d\n", binaryImg.at<unsigned char>(checkPt[1],checkPt[0]),
+            //                                        binaryImg.at<unsigned char>(checkPt[3],checkPt[2]),
+            //                                        binaryImg.at<unsigned char>(checkPt[5],checkPt[4]),
+            //                                        binaryImg.at<unsigned char>(checkPt[7],checkPt[6]));
+
+            float r_angle;
+            int iDir = -1;
+            if (maskfororientation.at<unsigned char>(checkPt[1],checkPt[0]) == 0){
+                iDir = 0;
+                r_angle=output[0].angle+180;}
+            else if (maskfororientation.at<unsigned char>(checkPt[3],checkPt[2]) == 0){
+                iDir = 1;
+                r_angle=output[0].angle+270;}
+            else if (maskfororientation.at<unsigned char>(checkPt[5],checkPt[4]) == 0){
+                iDir = 2;
+                r_angle=output[0].angle+360;}
+            else if (maskfororientation.at<unsigned char>(checkPt[7],checkPt[6]) == 0){
+                iDir = 3;
+                r_angle=output[0].angle+90;}
+            circle(camera, Point(checkPt[iDir*2], checkPt[iDir*2+1]), 5, Scalar(255,0,0));
+            printf("Robot Angle: %.2f\n",r_angle);
 
-        for( int i = 0; i < cnts2.size(); i++ ){
-            output2[i] = minAreaRect(cnts2[i]);
-        }
-        float c_x=output2[0].center.x;
-        float c_y=output2[0].center.y;
-        float c_w=output2[0].size.width;
-        float c_h=output2[0].size.height;
-        float c_angle=output2[0].angle;
-        if (c_w<c_h){
-            c_angle=90-c_angle;
         }
         else {
-            c_angle=0-c_angle;
+            break;
         }
-        printf("Cargo Angle: %.2f\n",c_angle);
-		drawContours(frame,cnts2,0,Scalar(0,255,0),2);
-
-        putText(frame,"Cargo",Point((int)c_x,(int)c_y),FONT_HERSHEY_SIMPLEX,0.5,255,2);
-
-
-        //get robot angle___________________________________________________________________________
-        threshold (frame, binaryImg, 65, 255, THRESH_BINARY_INV );
-        float tempAngle = output[0].angle;          // get angle of rotated rect
-        int checkPt[8];
-        //printf("angle: %.3f, width: %.3f, height: %.3f\n", tempAngle, width, height);
-        checkPt[0] = r_x - 0.4 * r_w  * cosd(tempAngle);
-        checkPt[1] = r_y - 0.4 * r_h * sind(tempAngle);
-        checkPt[2] = r_x + 0.4 * r_h * sind(tempAngle);
-        checkPt[3] = r_y - 0.4 * r_h * cosd(tempAngle);
-        checkPt[4] = r_x + 0.4 * r_w  * cosd(tempAngle);
-        checkPt[5] = r_y + 0.4 * r_h * sind(tempAngle);
-        checkPt[6] = r_x - 0.4 * r_w  * sind(tempAngle);
-        checkPt[7] = r_y + 0.4 * r_h * cosd(tempAngle);
-        //printf("binary image channel %d depth %d\n", binaryImg.channels(), binaryImg.depth());
-        //printf("pt1 %d pt2 %d pt3 %d pt4 %d\n", binaryImg.at<unsigned char>(checkPt[1],checkPt[0]),
-        //                                        binaryImg.at<unsigned char>(checkPt[3],checkPt[2]),
-        //                                        binaryImg.at<unsigned char>(checkPt[5],checkPt[4]),
-        //                                        binaryImg.at<unsigned char>(checkPt[7],checkPt[6]));
-
-        float r_angle;
-        int iDir = -1;
-        if (maskfororientation.at<unsigned char>(checkPt[1],checkPt[0]) == 0){
-            iDir = 0;
-            r_angle=output[0].angle+180;}
-        else if (maskfororientation.at<unsigned char>(checkPt[3],checkPt[2]) == 0){
-            iDir = 1;
-            r_angle=output[0].angle+270;}
-        else if (maskfororientation.at<unsigned char>(checkPt[5],checkPt[4]) == 0){
-            iDir = 2;
-            r_angle=output[0].angle+360;}
-        else if (maskfororientation.at<unsigned char>(checkPt[7],checkPt[6]) == 0){
-            iDir = 3;
-            r_angle=output[0].angle+90;}
-        circle(frame, Point(checkPt[iDir*2], checkPt[iDir*2+1]), 5, Scalar(255,0,0));
-        printf("Robot Angle: %.2f\n",r_angle);
-        //___________________________________________________________________________________
-        // printf("Angle: %.2f\n",r_angle);
-        // printf("X Position: %.2f\n",r_x);
-        // printf("Y Position: %.2f\n",r_y);
+        imshow("camera",camera);
 
-    }
-    else {
-        break;
-    }
+        char c=(char)waitKey(1);
+        if(c==27) break;
+      }
+  }
 
-    imshow( "Frame", frame);
+  //pause();
+  // cap.release();
+  // destroyAllWindows();
 
-    char c=(char)waitKey(25);
-    if(c==27)
-      break;
-  }
-  //NETUSBCAM_Stop(0);
-  cap.release();
-  destroyAllWindows();
+  // stop streaming of camera
+  result = NETUSBCAM_Stop(0);
+  if(result!=0){
+      printf("Error: Stop; Result = %d\n", result);
+      return 0; }
+
+  // close camera
+  result = NETUSBCAM_Close(0);
+  if(result!=0){
+      printf("Error: Close; Result = %d\n", result);
+      return 0; }
 
   return 0;
 }
diff --git a/York/test-triangle b/York/test-triangle
index 71417c1..f78491d 100755
Binary files a/York/test-triangle and b/York/test-triangle differ
diff --git a/York/test-triangle.cpp b/York/test-triangle.cpp
index b96faff..1bfddc6 100644
--- a/York/test-triangle.cpp
+++ b/York/test-triangle.cpp
@@ -2,14 +2,20 @@
 #include <iostream>
 #include <stdio.h>
 #include <vector>
-#include <iostream>
 #include <string.h>
 #include "general_header.hpp"
 #include "NETUSBCAM_API.h"
 #include "ICubeDefines.h"
-//Read: usable variables: Robot: r_x,r_y,r_angle; Cargo: c_x,c_y,c_angle
+#include <unistd.h>
+#include <signal.h>
+
+#include "opencv2/objdetect.hpp"
+#include "opencv2/highgui.hpp"
+#include "opencv2/imgproc.hpp"
+
+//Read: usable variables: Robot: r_x,r_y,r_angle; Cargo: c_x,c_y
 
-//~/Desktop/Undergraduate_Thesis/York$ g++ `pkg-config --cflags gtk+-3.0` `pkg-config --cflags opencv` -o test test.cpp `pkg-config --libs opencv` `pkg-config --libs gtk+-3.0` -lNETUSBCAM
+//~/Desktop/Undergraduate_Thesis/York$ g++ `pkg-config --cflags gtk+-3.0` `pkg-config --cflags opencv` -o test test.cpp `pkg-config --libs opencv` `pkg-config --libs gtk+-3.0` -lNETUSBCAM -std=c++11
 //~/Desktop/Undergraduate_Thesis/York$ ./test
 
 using namespace std;
@@ -21,185 +27,279 @@ bool compareContourAreas ( vector<Point> contour1, vector<Point> contour2 ) {
     return ( i < j );
 }
 
-// unsigned int nGoodCnt=0;
-// unsigned int nBadCnt=0;
-// int GetImage(void *buffer, unsigned int buffersize, void *context)
-// {
-//   if(buffersize==0){		// badframe arrived (this happens here, when (REG_CALLBACK_BR_FRAMES==1)
-// 	nBadCnt++;
-//   }
-//   else				// good frame arrived
-//   {
-// 	nGoodCnt++;
-//   char filename[24];
-//   sprintf(filename,"Output%d.jpg",nGoodCnt);
-//   printf("%p",buffer);
-//
-// 	#ifdef SAVE_RAW
-//   printf("%p\n", buffer);
-// 	char buf[24];
-// 	sprintf(buf,"Nr%d.raw",nGoodCnt);
-// 	SaveRaw((unsigned char*)buffer,buffersize,buf);
-// 	#endif
-//   }
-// }
+void SignalHandler(int i)
+{
+   signal(SIGINT, SignalHandler);
+}
+
+Mat camera;
+int GetImage(void *buffer, unsigned int buffersize, void *context)
+{
+  camera = Mat(1024,1280, CV_8UC3, buffer);
+}
+
+int ifframe(Mat camera){
+    Size s = camera.size();
+    int rows = s.height;
+    int cols = s.width;
+    if (rows > 0 && cols > 0){
+        return 1;
+    } else{
+        return 0;
+    }
+}
 
 int main(){
+    int result=0;
+    result = NETUSBCAM_Init();		// look for ICubes
+	if(result==0){
+		printf("No device\n");
+		return 0; }
+
+  	signal(SIGINT, SignalHandler);		// register signal handler for Ctrl+C
+
+	result = NETUSBCAM_Open(0);	// open camera
+	if(result!=0){
+		printf("Error: Open; Result = %d\n", result);
+		return 0; }
+
+    // set the camera clock lower, if a lot of bad frames arriving
+	result = NETUSBCAM_SetCamParameter(0,REG_PLL,20);
+	if(result!=0){
+		printf("Error: REG_PLL; Result = %d\n", result);
+		return 0; }
+
+	// if active, badframes are sent to the callback with buffersize = 0
+	result = NETUSBCAM_SetCamParameter(0,REG_CALLBACK_BR_FRAMES,1);
+	if(result!=0){
+		printf("Error: REG_CALLBACK_BR_FRAMES; Result = %d\n", result);
+		return 0; }
+
+    // set the callback to get the frame buffer
+  	result = NETUSBCAM_SetCallback(0,CALLBACK_RGB,&GetImage,NULL);
+  	if(result!=0){
+  		printf("Error: SetCallback; Result = %d\n", result);
+  		return 0; }
+
+  	 // start streaming of camera
+  	result = NETUSBCAM_Start(0);
+  	if(result!=0){
+  		printf("Error: Start; Result = %d\n", result);
+  		return 0; }
 
-  // Create a VideoCapture object and open the input file
-  // If the input is the web camera, pass 0 instead of the video file name
-
-  // NETUSBCAM_Init();
-  // NETUSBCAM_Open(0);
-  // NETUSBCAM_SetCamParameter(0,REG_PLL,20);
-  // NETUSBCAM_SetCamParameter(0,REG_CALLBACK_BR_FRAMES,1);
-  // NETUSBCAM_SetCallback(0,CALLBACK_RGB,&GetImage,NULL);
-  // NETUSBCAM_Start(0);
-  VideoCapture cap("test2.mp4");
-  if(!cap.isOpened()){
-    cout << "Error opening video stream or file" << endl;
-    return -1;
-  }
   int mouse_x_1;
   int mouse_y_1;
   int mouse_x_2;
   int mouse_y_2;
+  int mouse_x_3;
+  int mouse_y_3;
+  int mouse_x_4;
+  int mouse_y_4;
+  int mouse_x_5;
+  int mouse_y_5;
+  int mouse_x_6;
+  int mouse_y_6;
   int arena_w=400;//abs(mouse_x_1-mouse_x_2);
   int arena_h=300;//abs(mouse_y_1-mouse_y_2);
   int occupy[arena_h][arena_w];//the occupy matrix has the size of the arena
-  Mat frame;
+  //Mat frame;
   Mat hsv;
   Mat mask;
   Mat mask2;
   Mat binaryImg;
-  vector<vector<Point> > cnts;
-  vector<vector<Point> > cnts2;
   while(1){
 
-    cap >> frame;
-    if (frame.empty())
-      break;
-    frame=frame(Rect(50,40,580,350)); //crop the frame
-    cvtColor(frame,hsv,COLOR_BGR2GRAY);
-    inRange(hsv,0,60,mask);
-    Mat maskfororientation = mask;
-    erode(mask,mask,Mat(),Point(-1,-1),2);
-    dilate(mask,mask,Mat(),Point(-1,-1),2);
-    imshow("hsv", mask);
-	inRange(hsv,80,230,mask2);
-    erode(mask2,mask2,Mat(),Point(-1,-1),2);
-    dilate(mask2,mask2,Mat(),Point(-1,-1),2);
-    for (int w=0; w<arena_w; w++){
-        for (int h=0; h<arena_h; h++){
-            if (mask.at<int>(h,w)==255){
-                occupy[h][w]=1;
+    if(ifframe(camera)){
+
+        vector<vector<Point> > cnts;
+        vector<vector<Point> > cnts2;
+        //cap >> frame;
+        // if (camera.empty())
+        //   break;
+        //frame=frame(Rect(50,40,580,350)); //crop the frame
+
+//draw arena--------------
+        line(camera,Point(mouse_x_1,mouse_y_1),Point(mouse_x_1+arena_w,mouse_y_1),Scalar(0,255,0),3);
+        line(camera,Point(mouse_x_1,mouse_y_1),Point(mouse_x_1,mouse_y_1-arena_h),Scalar(0,255,0),3);
+        line(camera,Point(mouse_x_2,mouse_y_2),Point(mouse_x_1+arena_w,mouse_y_1),Scalar(0,255,0),3);
+        line(camera,Point(mouse_x_2,mouse_y_2),Point(mouse_x_1,mouse_y_1-arena_h),Scalar(0,255,0),3);
+        line(camera,Point(mouse_x_3,mouse_y_3),Point(mouse_x_4,mouse_y_4),Scalar(0,255,0),3);
+        line(camera,Point(mouse_x_5,mouse_y_5),Point(mouse_x_6,mouse_y_6),Scalar(0,255,0),3);
+//---------
+        cvtColor(camera,hsv,COLOR_BGR2GRAY);
+        inRange(hsv,0,80,mask);
+        Mat maskfororientation = mask;
+        erode(mask,mask,Mat(),Point(-1,-1),2);
+        dilate(mask,mask,Mat(),Point(-1,-1),2);
+    	inRange(hsv,80,230,mask2);
+        erode(mask2,mask2,Mat(),Point(-1,-1),2);
+        dilate(mask2,mask2,Mat(),Point(-1,-1),2);
+        for (int w=0; w<arena_w; w++){
+            occupy[0][w]=3;
+            occupy[arena_h-1][w]=3;
+            for (int j=mouse_y_3; j<mouse_y_4;j++){
+                occupy[j][w]=3;
             }
-            if (mask2.at<int>(h,w)==255){
-                occupy[h][w]=2;
+            for (int j=mouse_y_5; j<mouse_y_6;j++){
+                occupy[j][w]=3;
+            }
+            for (int h=0; h<arena_h; h++){
+                occupy[h][0]=3;
+                occupy[h][arena_w-1]=3;
+                if (mask.at<int>(h,w)==255){
+                    occupy[h][w]=1;
+                }
+                if (mask2.at<int>(h,w)==255){
+                    occupy[h][w]=2;
+                }
             }
         }
-    }
 
-    findContours(mask,cnts,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE,Point(0,0));
-	findContours(mask2,cnts2,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE,Point(0,0));
 
-    if ((int)cnts.size()>0){
+        findContours(mask,cnts,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE,Point(0,0));
+        findContours(mask2,cnts2,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE,Point(0,0));
 
-        sort(cnts.begin(), cnts.end(),compareContourAreas);
+        if ((int)cnts.size()>0){
 
-    	sort(cnts2.begin(), cnts2.end(),compareContourAreas);
+            sort(cnts.begin(), cnts.end(),compareContourAreas);
 
-        //printf("size: %d\n", (int)cnts.size());
-        vector<RotatedRect> output(cnts.size());
-        vector<RotatedRect> output2(cnts2.size());
+            sort(cnts2.begin(), cnts2.end(),compareContourAreas);
 
-        for( int i = 0; i < cnts.size(); i++ ){
-            output[i] = minAreaRect(cnts[i]);
-        }
-        float r_x=output[0].center.x;
-        float r_y=output[0].center.y;
-        float r_w=output[0].size.width;
-        float r_h=output[0].size.height;
+            //printf("size: %d\n", (int)cnts.size());
+            vector<RotatedRect> output(cnts.size());
+            vector<RotatedRect> output2(cnts2.size());
 
-		drawContours(frame,cnts,0,Scalar(0,0,255),2);
-        putText(frame,"Robot",Point((int)r_x,(int)r_y),FONT_HERSHEY_SIMPLEX,0.5,255,2);
+            for( int i = 0; i < cnts.size(); i++ ){
+                output[i] = minAreaRect(cnts[i]);
+            }
+            float r_x=output[0].center.x;
+            float r_y=output[0].center.y;
+            float r_w=output[0].size.width;
+            float r_h=output[0].size.height;
 
-        //for( int i = 0; i < cnts2.size(); i++ ){
+            drawContours(camera,cnts,0,Scalar(0,0,255),2);
+            putText(camera,"Robot",Point((int)r_x,(int)r_y),FONT_HERSHEY_SIMPLEX,0.5,255,2);
 
-        for( int i = 0; i < cnts2.size(); i++ ){
-            output2[i] = minAreaRect(cnts2[i]);
-        }
-        float c_x=moments(cnts2[0]).m10/moments(cnts2[0]).m00; //use moments function to calculate center for triangle
-        float c_y=moments(cnts2[0]).m01/moments(cnts2[0]).m00;
-        float c_w=output2[0].size.width;
-        float c_h=output2[0].size.height;
-        float c_angle=output2[0].angle;
-        if (c_w<c_h){
-            c_angle=90-c_angle;
+            //for( int i = 0; i < cnts2.size(); i++ ){
+
+
+            float c_x=moments(cnts2[0]).m10/moments(cnts2[0]).m00; //use moments function to calculate center for triangle
+            float c_y=moments(cnts2[0]).m01/moments(cnts2[0]).m00;
+
+            vector<Point2f> triangle;
+            minEnclosingTriangle(cnts2[0],triangle);
+
+            float x1=triangle[0].x;
+            float y1=triangle[0].y;
+            float x2=triangle[1].x;
+            float y2=triangle[1].y;
+            float x3=triangle[2].x;
+            float y3=triangle[2].y;
+            float s1[5]={sqrt(pow((x1-x2),2)+pow((y1-y2),2)),x1,y1,x2,y2};
+            float s2[5]={sqrt(pow((x1-x3),2)+pow((y1-y3),2)),x1,y1,x3,y3};
+            float s3[5]={sqrt(pow((x2-x3),2)+pow((y2-y3),2)),x2,y2,x3,y3};
+            float vertice[6]; //first one is C-hypotenus, second is B-longer side, third is A-short side
+
+            if (min({s1[0],s2[0],s3[0]})==s1[0]){
+                if (min(s2[0],s3[0])==s2[0]){
+                    vertice[0]=x3;vertice[1]=y3;vertice[2]=x1;vertice[3]=y1;vertice[4]=x2;vertice[5]=y2;
+                }
+                else {
+                    vertice[0]=x3;vertice[1]=y3;vertice[2]=x2;vertice[3]=y2;vertice[4]=x1;vertice[5]=y1;
+                }
+            }
+            if (min({s1[0],s2[0],s3[0]})==s2[0]){
+                if (min(s1[0],s3[0])==s1[0]){
+                    vertice[0]=x2;vertice[1]=y2;vertice[2]=x1;vertice[3]=y1;vertice[4]=x3;vertice[5]=y3;
+                }
+                else {
+                    vertice[0]=x2;vertice[1]=y2;vertice[2]=x3;vertice[3]=y3;vertice[4]=x1;vertice[5]=y1;
+                }
+            }
+            if (min({s1[0],s2[0],s3[0]})==s3[0]){
+                if (min(s1[0],s2[0])==s1[0]){
+                    vertice[0]=x1;vertice[1]=y1;vertice[2]=x2;vertice[3]=y2;vertice[4]=x3;vertice[5]=y3;
+                }
+                else {
+                    vertice[0]=x1;vertice[1]=y1;vertice[2]=x3;vertice[3]=y3;vertice[4]=x2;vertice[5]=y2;
+                }
+            }
+
+            float c_angle=asin(abs(vertice[1]-vertice[3])/sqrt(pow((vertice[1]-vertice[3]),2)+pow(abs(vertice[0]-vertice[2]),2)));
+
+
+
+            printf("Cargo Angle: %.2f\n",c_angle);
+            drawContours(camera,cnts2,0,Scalar(0,255,0),2);
+
+            putText(camera,"Cargo",Point((int)c_x,(int)c_y),FONT_HERSHEY_SIMPLEX,0.5,255,2);
+
+
+            //get robot angle___________________________________________________________________________
+            threshold (camera, binaryImg, 65, 255, THRESH_BINARY_INV );
+            float tempAngle = output[0].angle;          // get angle of rotated rect
+            int checkPt[8];
+            //printf("angle: %.3f, width: %.3f, height: %.3f\n", tempAngle, width, height);
+            checkPt[0] = r_x - 0.4 * r_w  * cosd(tempAngle);
+            checkPt[1] = r_y - 0.4 * r_h * sind(tempAngle);
+            checkPt[2] = r_x + 0.4 * r_h * sind(tempAngle);
+            checkPt[3] = r_y - 0.4 * r_h * cosd(tempAngle);
+            checkPt[4] = r_x + 0.4 * r_w  * cosd(tempAngle);
+            checkPt[5] = r_y + 0.4 * r_h * sind(tempAngle);
+            checkPt[6] = r_x - 0.4 * r_w  * sind(tempAngle);
+            checkPt[7] = r_y + 0.4 * r_h * cosd(tempAngle);
+
+            float r_angle;
+            int iDir = -1;
+            if (maskfororientation.at<unsigned char>(checkPt[1],checkPt[0]) == 0){
+                iDir = 0;
+                r_angle=output[0].angle+180;}
+            else if (maskfororientation.at<unsigned char>(checkPt[3],checkPt[2]) == 0){
+                iDir = 1;
+                r_angle=output[0].angle+270;}
+            else if (maskfororientation.at<unsigned char>(checkPt[5],checkPt[4]) == 0){
+                iDir = 2;
+                r_angle=output[0].angle+360;}
+            else if (maskfororientation.at<unsigned char>(checkPt[7],checkPt[6]) == 0){
+                iDir = 3;
+                r_angle=output[0].angle+90;}
+            circle(camera, Point(checkPt[iDir*2], checkPt[iDir*2+1]), 5, Scalar(255,0,0));
+            printf("Robot Angle: %.2f\n",r_angle);
+
+// draw path---------------------------
+            // while(!Path.empty()){
+            //     Pair p = Path.top();
+            //     Path.pop();
+            //     circle(camera, Point(p.second,p.first), 1, Scalar(255,0,0), -1);
+            //     }
+//-----------------------------------------
         }
         else {
-            c_angle=0-c_angle;
+            break;
         }
-        printf("Cargo Angle: %.2f\n",c_angle);
-		drawContours(frame,cnts2,0,Scalar(0,255,0),2);
-
-        putText(frame,"Cargo",Point((int)c_x,(int)c_y),FONT_HERSHEY_SIMPLEX,0.5,255,2);
-
-
-        //get robot angle___________________________________________________________________________
-        threshold (frame, binaryImg, 65, 255, THRESH_BINARY_INV );
-        float tempAngle = output[0].angle;          // get angle of rotated rect
-        int checkPt[8];
-        //printf("angle: %.3f, width: %.3f, height: %.3f\n", tempAngle, width, height);
-        checkPt[0] = r_x - 0.4 * r_w  * cosd(tempAngle);
-        checkPt[1] = r_y - 0.4 * r_h * sind(tempAngle);
-        checkPt[2] = r_x + 0.4 * r_h * sind(tempAngle);
-        checkPt[3] = r_y - 0.4 * r_h * cosd(tempAngle);
-        checkPt[4] = r_x + 0.4 * r_w  * cosd(tempAngle);
-        checkPt[5] = r_y + 0.4 * r_h * sind(tempAngle);
-        checkPt[6] = r_x - 0.4 * r_w  * sind(tempAngle);
-        checkPt[7] = r_y + 0.4 * r_h * cosd(tempAngle);
-        //printf("binary image channel %d depth %d\n", binaryImg.channels(), binaryImg.depth());
-        //printf("pt1 %d pt2 %d pt3 %d pt4 %d\n", binaryImg.at<unsigned char>(checkPt[1],checkPt[0]),
-        //                                        binaryImg.at<unsigned char>(checkPt[3],checkPt[2]),
-        //                                        binaryImg.at<unsigned char>(checkPt[5],checkPt[4]),
-        //                                        binaryImg.at<unsigned char>(checkPt[7],checkPt[6]));
-
-        float r_angle;
-        int iDir = -1;
-        if (maskfororientation.at<unsigned char>(checkPt[1],checkPt[0]) == 0){
-            iDir = 0;
-            r_angle=output[0].angle+180;}
-        else if (maskfororientation.at<unsigned char>(checkPt[3],checkPt[2]) == 0){
-            iDir = 1;
-            r_angle=output[0].angle+270;}
-        else if (maskfororientation.at<unsigned char>(checkPt[5],checkPt[4]) == 0){
-            iDir = 2;
-            r_angle=output[0].angle+360;}
-        else if (maskfororientation.at<unsigned char>(checkPt[7],checkPt[6]) == 0){
-            iDir = 3;
-            r_angle=output[0].angle+90;}
-        circle(frame, Point(checkPt[iDir*2], checkPt[iDir*2+1]), 5, Scalar(255,0,0));
-        printf("Robot Angle: %.2f\n",r_angle);
-        //___________________________________________________________________________________
-        // printf("Angle: %.2f\n",r_angle);
-        // printf("X Position: %.2f\n",r_x);
-        // printf("Y Position: %.2f\n",r_y);
+        imshow("camera",camera);
 
-    }
-    else {
-        break;
-    }
+        char c=(char)waitKey(1);
+        if(c==27) break;
+      }
+  }
 
-    imshow( "Frame", frame);
+  //pause();
+  // cap.release();
+  // destroyAllWindows();
 
-    char c=(char)waitKey(25);
-    if(c==27)
-      break;
-  }
-  //NETUSBCAM_Stop(0);
-  cap.release();
-  destroyAllWindows();
+  // stop streaming of camera
+  result = NETUSBCAM_Stop(0);
+  if(result!=0){
+      printf("Error: Stop; Result = %d\n", result);
+      return 0; }
+
+  // close camera
+  result = NETUSBCAM_Close(0);
+  if(result!=0){
+      printf("Error: Close; Result = %d\n", result);
+      return 0; }
 
   return 0;
+
 }
